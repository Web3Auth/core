{"version":3,"file":"encryption.mjs","sourceRoot":"","sources":["../src/encryption.ts"],"names":[],"mappings":";;;;;;AAAA,OAAO,EAAE,GAAG,EAAE,2BAA2B;AACzC,OAAO,EAAE,eAAe,EAAE,6BAA6B;AACvD,OAAO,EAAE,SAAS,EAAE,gCAAgC;AACpD,OAAO,EAAE,IAAI,EAAE,2BAA2B;AAC1C,OAAO,EAAE,MAAM,EAAE,6BAA6B;AAC9C,OAAO,EAAE,WAAW,EAAE,4BAA4B;AAIlD,MAAM,OAAO,kBAAkB;IAA/B;QACW,uDAA4B,gBAAgB,EAAC;QAE7C,iDAAsB,oBAAoB,EAAC;QAE3C,wCAAa,EAAE,EAAC;IA8C3B,CAAC;IA5CC,OAAO,CAAC,GAAe,EAAE,IAAgB;QACvC,MAAM,KAAK,GAAG,WAAW,CAAC,EAAE,CAAC,CAAC;QAC9B,MAAM,GAAG,GAAG,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;QAE5B,MAAM,UAAU,GAAG,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QACrC,MAAM,aAAa,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC,CAAC;QACzD,OAAO,aAAa,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAC1C,CAAC;IAED,OAAO,CACL,GAAe,EACf,2BAAuC;QAEvC,MAAM,KAAK,GAAG,2BAA2B,CAAC,KAAK,CAAC,CAAC,EAAE,uBAAA,IAAI,qCAAW,CAAC,CAAC;QACpE,MAAM,UAAU,GAAG,2BAA2B,CAAC,KAAK,CAAC,uBAAA,IAAI,qCAAW,CAAC,CAAC;QAEtE,MAAM,GAAG,GAAG,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;QAC5B,MAAM,OAAO,GAAG,GAAG,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;QAExC,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,eAAe,CAAC,QAAgB;QAC9B,MAAM,IAAI,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;QAC9B,MAAM,GAAG,GAAG,IAAI,CACd,MAAM,EACN,IAAI,EACJ,SAAS,EACT,uBAAA,IAAI,oDAA0B,EAC9B,EAAE,CACH,CAAC;QACF,OAAO,GAAG,CAAC;IACb,CAAC;IAED,uBAAuB,CAAC,QAAgB;QACtC,MAAM,IAAI,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;QAC9B,MAAM,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,uBAAA,IAAI,8CAAoB,EAAE,EAAE,CAAC,CAAC,CAAC,sBAAsB;QAE7F,sEAAsE;QACtE,4EAA4E;QAC5E,MAAM,EAAE,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;QAClD,MAAM,EAAE,GAAG,SAAS,CAAC,YAAY,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;QAC7C,OAAO,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;IACpB,CAAC;CACF","sourcesContent":["import { gcm } from '@noble/ciphers/aes';\nimport { bytesToNumberBE } from '@noble/ciphers/utils';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { hkdf } from '@noble/hashes/hkdf';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\n\nimport type { KeyPair } from './ToprfClient';\n\nexport class EncryptorDecryptor {\n  readonly #HKDF_ENCRYPTION_KEY_INFO = 'encryption-key';\n\n  readonly #HKDF_AUTH_KEY_INFO = 'authentication-key';\n\n  readonly #nonceSize = 24;\n\n  encrypt(key: Uint8Array, data: Uint8Array): string {\n    const nonce = randomBytes(24);\n    const aes = gcm(key, nonce);\n\n    const cipherText = aes.encrypt(data);\n    const encryptedData = Buffer.concat([nonce, cipherText]);\n    return encryptedData.toString('base64');\n  }\n\n  decrypt(\n    key: Uint8Array,\n    cipherTextCombinedWithNonce: Uint8Array,\n  ): Uint8Array {\n    const nonce = cipherTextCombinedWithNonce.slice(0, this.#nonceSize);\n    const rawEncData = cipherTextCombinedWithNonce.slice(this.#nonceSize);\n\n    const aes = gcm(key, nonce);\n    const rawData = aes.decrypt(rawEncData);\n\n    return rawData;\n  }\n\n  keyFromPassword(password: string): Uint8Array {\n    const seed = sha256(password);\n    const key = hkdf(\n      sha256,\n      seed,\n      undefined,\n      this.#HKDF_ENCRYPTION_KEY_INFO,\n      32,\n    );\n    return key;\n  }\n\n  authKeyPairFromPassword(password: string): KeyPair {\n    const seed = sha256(password);\n    const k = hkdf(sha256, seed, undefined, this.#HKDF_AUTH_KEY_INFO, 32); // Derive 256 bit key.\n\n    // Converting from bytes to scalar like this is OK because statistical\n    // distance between U(2^256) % secp256k1.n and U(secp256k1.n) is negligible.\n    const sk = bytesToNumberBE(k) % secp256k1.CURVE.n;\n    const pk = secp256k1.getPublicKey(sk, false);\n    return { sk, pk };\n  }\n}\n"]}