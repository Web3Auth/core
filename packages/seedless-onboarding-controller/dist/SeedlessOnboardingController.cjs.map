{"version":3,"file":"SeedlessOnboardingController.cjs","sourceRoot":"","sources":["../src/SeedlessOnboardingController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedMessenger,\n  StateMetadata,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport {\n  encryptWithKey,\n  decryptWithKey,\n  keyFromPassword,\n  generateSalt,\n  importKey,\n  exportKey,\n} from '@metamask/browser-passworder';\nimport type { KeyringControllerStateChangeEvent } from '@metamask/keyring-controller';\nimport { Mutex, type MutexInterface } from 'async-mutex';\n\nimport { SeedlessOnboardingControllerError } from './constants';\nimport { ToprfAuthClient } from './ToprfClient';\nimport type {\n  AuthenticateUserParams,\n  CreateSeedlessBackupParams,\n  Encryptor,\n  NodeAuthTokens,\n} from './types';\n\nconst controllerName = 'SeedlessOnboardingController';\n\n/**\n * A function executed within a mutually exclusive lock, with\n * a mutex releaser in its option bag.\n *\n * @param releaseLock - A function to release the lock.\n */\ntype MutuallyExclusiveCallback<Result> = ({\n  releaseLock,\n}: {\n  releaseLock: MutexInterface.Releaser;\n}) => Promise<Result>;\n\n// State\nexport type SeedlessOnboardingControllerState = {\n  /**\n   * Encrypted array of serialized keyrings data.\n   */\n  vault?: string;\n  /**\n   * The node auth tokens from OAuth User authentication after the Social login.\n   *\n   * This values are used to authenticate users when they go through the Seedless Onboarding flow.\n   */\n  nodeAuthTokens?: NodeAuthTokens;\n  /**\n   * Indicates whether the user has already fully/partially completed the Seedless Onboarding flow.\n   *\n   * An encryption key is generated from user entered password using Threshold OPRF and the seed phrase is encrypted with the key.\n   * During the Seedless Onboarding Authentication step, TOPRF services check whether user has already generated the encryption key.\n   *\n   * If this value is `true`, we can assume that user already has completed the `SeedPhrase` generation step, and user will have to\n   * fetch the `SeedPhrase` with correct password. Otherwise, users will be asked to set up seedphrase and password, first.\n   */\n  hasValidEncryptionKey?: boolean;\n};\n\n// Actions\nexport type SeedlessOnboardingControllerGetStateActions =\n  ControllerGetStateAction<\n    typeof controllerName,\n    SeedlessOnboardingControllerState\n  >;\n\nexport type AllowedActions = SeedlessOnboardingControllerGetStateActions;\n\nexport type SeedlessOnboardingControllerStateChangeEvent =\n  ControllerStateChangeEvent<\n    typeof controllerName,\n    SeedlessOnboardingControllerState\n  >;\n\n// events allowed to be subscribed\nexport type AllowedEvents =\n  | KeyringControllerStateChangeEvent\n  | SeedlessOnboardingControllerStateChangeEvent;\n\n// Messenger\n// TODO: re-evaluate and remove uncessary events/actions from the messenger\nexport type SeedlessOnboardingControllerMessenger = RestrictedMessenger<\n  typeof controllerName,\n  AllowedActions,\n  AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nexport type SeedlessOnboardingControllerOptions = {\n  messenger: SeedlessOnboardingControllerMessenger;\n\n  /**\n   * @description Initial state to set on this controller.\n   */\n  state?: SeedlessOnboardingControllerState;\n\n  /**\n   * @description Encryptor used for encryption and decryption of data.\n   * @default WebCryptoAPI\n   */\n  encryptor?: Encryptor;\n};\n\n/**\n * Seedless Onboarding Controller State Metadata.\n *\n * This allows us to choose if fields of the state should be persisted or not\n * using the `persist` flag; and if they can be sent to Sentry or not, using\n * the `anonymous` flag.\n */\nconst seedlessOnboardingMetadata: StateMetadata<SeedlessOnboardingControllerState> =\n  {\n    vault: {\n      persist: true,\n      anonymous: false,\n    },\n    hasValidEncryptionKey: {\n      persist: true,\n      anonymous: false,\n    },\n    nodeAuthTokens: {\n      persist: false,\n      anonymous: true,\n    },\n  };\n\nexport const defaultState: SeedlessOnboardingControllerState = {\n  hasValidEncryptionKey: false,\n};\n\nexport class SeedlessOnboardingController extends BaseController<\n  typeof controllerName,\n  SeedlessOnboardingControllerState,\n  SeedlessOnboardingControllerMessenger\n> {\n  readonly #encryptor: Encryptor = {\n    keyFromPassword: (password, salt, exportable, opts) => {\n      const randomSalt = salt || Math.random().toString(36).substring(2, 15);\n      const exportableKey = exportable ?? true;\n      return keyFromPassword(password, randomSalt, exportableKey, opts);\n    },\n    encryptWithKey,\n    decryptWithKey,\n    generateSalt,\n    importKey,\n    exportKey,\n  };\n\n  readonly #vaultOperationMutex = new Mutex();\n\n  readonly toprfAuthClient: ToprfAuthClient;\n\n  constructor({\n    messenger,\n    encryptor,\n    state,\n  }: SeedlessOnboardingControllerOptions) {\n    super({\n      messenger,\n      metadata: seedlessOnboardingMetadata,\n      name: controllerName,\n      state: { ...state, ...defaultState },\n    });\n    if (encryptor) {\n      this.#encryptor = encryptor;\n    }\n    this.toprfAuthClient = new ToprfAuthClient();\n  }\n\n  /**\n   * @description Authenticate OAuth user using the seedless onboarding flow\n   * and determine if the user is already registered or not.\n   * @param params - The parameters for authenticate OAuth user.\n   * @param params.idToken - The ID token from Social login\n   * @param params.verifier - OAuth verifier\n   * @param params.verifierId - user email or id from Social login\n   * @returns A promise that resolves to the authentication result.\n   */\n  async authenticateOAuthUser(params: AuthenticateUserParams) {\n    const verificationResult = await this.toprfAuthClient.authenticate(params);\n    this.update((state) => {\n      state.nodeAuthTokens = verificationResult.nodeAuthTokens;\n      state.hasValidEncryptionKey = verificationResult.hasValidEncKey;\n    });\n    return verificationResult;\n  }\n\n  /**\n   * @description Backup seed phrase using the seedless onboarding flow.\n   * @param params - The parameters for backup seed phrase.\n   * @param params.password - The password used to create new wallet and seedphrase\n   * @param params.seedPhrase - The seed phrase to backup\n   * @returns A promise that resolves to the encrypted seed phrase and the encryption key.\n   */\n  async createSeedPhraseBackup({\n    password,\n    seedPhrase,\n  }: CreateSeedlessBackupParams): Promise<{\n    encryptedSeedPhrase: string;\n    encryptionKey: string;\n  }> {\n    const nodeAuthTokens = this.#getNodeAuthTokens();\n    const { encKey } = await this.toprfAuthClient.createEncKey({\n      nodeAuthTokens,\n      password,\n    });\n\n    const storeResult = await this.toprfAuthClient.storeSecretData({\n      nodeAuthTokens,\n      encKey,\n      secretData: seedPhrase,\n    });\n\n    await this.#createNewVaultWithAuthData({\n      password,\n      authTokens: nodeAuthTokens,\n      toprfEncryptionKey: storeResult.encKey,\n    });\n\n    return {\n      encryptedSeedPhrase: storeResult.encryptedSecretData,\n      encryptionKey: storeResult.encKey,\n    };\n  }\n\n  /**\n   * @description Fetch seed phrase metadata from the metadata store.\n   * @param password - The password used to create new wallet and seedphrase\n   * @returns A promise that resolves to the seed phrase metadata.\n   */\n  async fetchAndRestoreSeedPhraseMetadata(password: string) {\n    try {\n      const nodeAuthTokens = this.#getNodeAuthTokens();\n      const { encKey, secretData } = await this.toprfAuthClient.fetchSecretData(\n        {\n          nodeAuthTokens,\n          password,\n        },\n      );\n\n      if (secretData && secretData.length > 0) {\n        await this.#createNewVaultWithAuthData({\n          password,\n          authTokens: nodeAuthTokens,\n          toprfEncryptionKey: encKey,\n        });\n      }\n\n      return {\n        secretData,\n        encryptionKey: encKey,\n      };\n    } catch (error) {\n      console.error('[fetchAndRestoreSeedPhraseMetadata] error', error);\n      throw new Error(SeedlessOnboardingControllerError.IncorrectPassword);\n    }\n  }\n\n  /**\n   * @description Get the node auth tokens from the state.\n   * @returns The node auth tokens.\n   */\n  #getNodeAuthTokens() {\n    const { nodeAuthTokens } = this.state;\n    if (!nodeAuthTokens) {\n      throw new Error(SeedlessOnboardingControllerError.NoOAuthIdToken);\n    }\n    return nodeAuthTokens;\n  }\n\n  async #createNewVaultWithAuthData({\n    password,\n    authTokens,\n    toprfEncryptionKey,\n  }: {\n    password: string;\n    authTokens: NodeAuthTokens;\n    toprfEncryptionKey: string;\n  }): Promise<void> {\n    await this.#updateVault({\n      password,\n      vaultData: {\n        authTokens,\n        toprfEncryptionKey,\n      },\n    });\n  }\n\n  #updateVault({\n    password,\n    vaultData,\n  }: {\n    password: string;\n    vaultData: object;\n  }): Promise<boolean> {\n    return this.#withVaultLock(async () => {\n      if (!password) {\n        throw new Error(SeedlessOnboardingControllerError.MissingCredentials);\n      }\n\n      const serializedAuthData = await this.#getSerializedVaultData(vaultData);\n\n      const updatedState: Partial<SeedlessOnboardingControllerState> = {};\n\n      assertIsValidPassword(password);\n      const key = await this.#encryptor.keyFromPassword(password);\n      const result = await this.#encryptor.encryptWithKey(\n        key,\n        serializedAuthData,\n      );\n      updatedState.vault = result.data;\n\n      if (!updatedState.vault) {\n        throw new Error(SeedlessOnboardingControllerError.MissingVaultData);\n      }\n\n      this.update((state) => {\n        state.vault = updatedState.vault;\n      });\n\n      return true;\n    });\n  }\n\n  /**\n   * Lock the vault mutex before executing the given function,\n   * and release it after the function is resolved or after an\n   * error is thrown.\n   *\n   * This ensures that each operation that interacts with the vault\n   * is executed in a mutually exclusive way.\n   *\n   * @param callback - The function to execute while the vault mutex is locked.\n   * @returns The result of the function.\n   */\n  async #withVaultLock<Result>(\n    callback: MutuallyExclusiveCallback<Result>,\n  ): Promise<Result> {\n    return withLock(this.#vaultOperationMutex, callback);\n  }\n\n  async #getSerializedVaultData(data: object): Promise<string> {\n    return JSON.stringify(data);\n  }\n}\n\n/**\n * Assert that the provided password is a valid non-empty string.\n *\n * @param password - The password to check.\n * @throws If the password is not a valid string.\n */\nfunction assertIsValidPassword(password: unknown): asserts password is string {\n  if (typeof password !== 'string') {\n    throw new Error(SeedlessOnboardingControllerError.WrongPasswordType);\n  }\n\n  if (!password || !password.length) {\n    throw new Error(SeedlessOnboardingControllerError.InvalidEmptyPassword);\n  }\n}\n\n/**\n * Lock the given mutex before executing the given function,\n * and release it after the function is resolved or after an\n * error is thrown.\n *\n * @param mutex - The mutex to lock.\n * @param callback - The function to execute while the mutex is locked.\n * @returns The result of the function.\n */\nasync function withLock<Result>(\n  mutex: Mutex,\n  callback: MutuallyExclusiveCallback<Result>,\n): Promise<Result> {\n  const releaseLock = await mutex.acquire();\n\n  try {\n    return await callback({ releaseLock });\n  } finally {\n    releaseLock();\n  }\n}\n"]}