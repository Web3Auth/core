{"version":3,"file":"SeedlessOnboardingController.mjs","sourceRoot":"","sources":["../src/SeedlessOnboardingController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedMessenger,\n  StateMetadata,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport { encrypt, decrypt } from '@metamask/browser-passworder';\nimport type { KeyringControllerStateChangeEvent } from '@metamask/keyring-controller';\nimport { utf8ToBytes } from '@noble/ciphers/utils';\nimport { Mutex, type MutexInterface } from 'async-mutex';\n\nimport { SeedlessOnboardingControllerError } from './constants';\nimport type { KeyPair } from './ToprfClient';\nimport { ToprfAuthClient } from './ToprfClient';\nimport type {\n  AuthenticateUserParams,\n  CreateSeedlessBackupParams,\n  Encryptor,\n  NodeAuthTokens,\n  OAuthVerifier,\n  UpdatePasswordParams,\n} from './types';\n\nconst controllerName = 'SeedlessOnboardingController';\n\n/**\n * A function executed within a mutually exclusive lock, with\n * a mutex releaser in its option bag.\n *\n * @param releaseLock - A function to release the lock.\n */\ntype MutuallyExclusiveCallback<Result> = ({\n  releaseLock,\n}: {\n  releaseLock: MutexInterface.Releaser;\n}) => Promise<Result>;\n\n// State\nexport type SeedlessOnboardingControllerState = {\n  /**\n   * Encrypted array of serialized keyrings data.\n   */\n  vault?: string;\n  /**\n   * The node auth tokens from OAuth User authentication after the Social login.\n   *\n   * This values are used to authenticate users when they go through the Seedless Onboarding flow.\n   */\n  nodeAuthTokens?: NodeAuthTokens;\n  /**\n   * Indicates whether the user has already fully/partially completed the Seedless Onboarding flow.\n   *\n   * An encryption key is generated from user entered password using Threshold OPRF and the seed phrase is encrypted with the key.\n   * During the Seedless Onboarding Authentication step, TOPRF services check whether user has already generated the encryption key.\n   *\n   * If this value is `true`, we can assume that user already has completed the `SeedPhrase` generation step, and user will have to\n   * fetch the `SeedPhrase` with correct password. Otherwise, users will be asked to set up seedphrase and password, first.\n   */\n  hasValidEncryptionKey?: boolean;\n};\n\n// Actions\nexport type SeedlessOnboardingControllerGetStateActions =\n  ControllerGetStateAction<\n    typeof controllerName,\n    SeedlessOnboardingControllerState\n  >;\n\nexport type AllowedActions = SeedlessOnboardingControllerGetStateActions;\n\nexport type SeedlessOnboardingControllerStateChangeEvent =\n  ControllerStateChangeEvent<\n    typeof controllerName,\n    SeedlessOnboardingControllerState\n  >;\n\n// events allowed to be subscribed\nexport type AllowedEvents =\n  | KeyringControllerStateChangeEvent\n  | SeedlessOnboardingControllerStateChangeEvent;\n\n// Messenger\n// TODO: re-evaluate and remove uncessary events/actions from the messenger\nexport type SeedlessOnboardingControllerMessenger = RestrictedMessenger<\n  typeof controllerName,\n  AllowedActions,\n  AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nexport type SeedlessOnboardingControllerOptions = {\n  messenger: SeedlessOnboardingControllerMessenger;\n\n  /**\n   * @description Initial state to set on this controller.\n   */\n  state?: SeedlessOnboardingControllerState;\n\n  /**\n   * @description Encryptor used for encryption and decryption of data.\n   * @default WebCryptoAPI\n   */\n  encryptor?: Encryptor;\n};\n\n/**\n * Seedless Onboarding Controller State Metadata.\n *\n * This allows us to choose if fields of the state should be persisted or not\n * using the `persist` flag; and if they can be sent to Sentry or not, using\n * the `anonymous` flag.\n */\nconst seedlessOnboardingMetadata: StateMetadata<SeedlessOnboardingControllerState> =\n  {\n    vault: {\n      persist: true,\n      anonymous: false,\n    },\n    hasValidEncryptionKey: {\n      persist: true,\n      anonymous: false,\n    },\n    nodeAuthTokens: {\n      persist: false,\n      anonymous: true,\n    },\n  };\n\nexport const defaultState: SeedlessOnboardingControllerState = {\n  hasValidEncryptionKey: false,\n};\n\nexport class SeedlessOnboardingController extends BaseController<\n  typeof controllerName,\n  SeedlessOnboardingControllerState,\n  SeedlessOnboardingControllerMessenger\n> {\n  readonly #encryptor: Encryptor = {\n    encrypt,\n    decrypt,\n  };\n\n  readonly #vaultOperationMutex = new Mutex();\n\n  readonly toprfAuthClient: ToprfAuthClient;\n\n  constructor({\n    messenger,\n    encryptor,\n    state,\n  }: SeedlessOnboardingControllerOptions) {\n    super({\n      messenger,\n      metadata: seedlessOnboardingMetadata,\n      name: controllerName,\n      state: { ...state, ...defaultState },\n    });\n    if (encryptor) {\n      this.#encryptor = encryptor;\n    }\n    this.toprfAuthClient = new ToprfAuthClient();\n  }\n\n  /**\n   * @description Authenticate OAuth user using the seedless onboarding flow\n   * and determine if the user is already registered or not.\n   * @param params - The parameters for authenticate OAuth user.\n   * @param params.idToken - The ID token from Social login\n   * @param params.verifier - OAuth verifier\n   * @param params.verifierId - user email or id from Social login\n   * @returns A promise that resolves to the authentication result.\n   */\n  async authenticateOAuthUser(params: AuthenticateUserParams) {\n    const verificationResult = await this.toprfAuthClient.authenticate(params);\n    this.update((state) => {\n      state.nodeAuthTokens = verificationResult.nodeAuthTokens;\n      state.hasValidEncryptionKey = verificationResult.hasValidEncKey;\n    });\n    return verificationResult;\n  }\n\n  /**\n   * @description Backup seed phrase using the seedless onboarding flow.\n   * @param params - The parameters for backup seed phrase.\n   * @param params.verifier - The login provider of the user.\n   * @param params.verifierID - The deterministic identifier of the user from the login provider.\n   * @param params.password - The password used to create new wallet and seedphrase\n   * @param params.seedPhrase - The seed phrase to backup\n   * @returns A promise that resolves to the encrypted seed phrase and the encryption key.\n   */\n  async createSeedPhraseBackup({\n    verifier,\n    verifierID,\n    password,\n    seedPhrase,\n  }: CreateSeedlessBackupParams): Promise<void> {\n    const nodeAuthTokens = this.#getNodeAuthTokens();\n    const { encKey, authKeyPair } = await this.toprfAuthClient.createEncKey({\n      nodeAuthTokens,\n      password,\n      verifier,\n      verifierID,\n    });\n\n    const seedPhraseBytes = utf8ToBytes(seedPhrase);\n    await this.toprfAuthClient.addSecretDataItem({\n      nodeAuthTokens,\n      encKey,\n      secretData: seedPhraseBytes,\n      authKeyPair,\n    });\n\n    await this.#createNewVaultWithAuthData({\n      password,\n      authTokens: nodeAuthTokens,\n      rawToprfEncryptionKey: encKey,\n      rawToprfAuthKeyPair: authKeyPair,\n    });\n  }\n\n  /**\n   * @description Fetch seed phrase metadata from the metadata store.\n   * @param verifier - The login provider of the user.\n   * @param verifierID - The deterministic identifier of the user from the login provider.\n   * @param password - The password used to create new wallet and seedphrase\n   * @returns A promise that resolves to the seed phrase metadata.\n   */\n  async fetchAndRestoreSeedPhraseMetadata(\n    verifier: OAuthVerifier,\n    verifierID: string,\n    password: string,\n  ): Promise<Uint8Array[]> {\n    const nodeAuthTokens = this.#getNodeAuthTokens();\n    const { encKey, authKeyPair } = await this.toprfAuthClient.createEncKey({\n      nodeAuthTokens,\n      password,\n      verifier,\n      verifierID,\n    });\n    const secretData = await this.toprfAuthClient.fetchSecretData({\n      nodeAuthTokens,\n      decKey: encKey,\n      authKeyPair,\n    });\n\n    if (secretData && secretData.length > 0) {\n      await this.#createNewVaultWithAuthData({\n        password,\n        authTokens: nodeAuthTokens,\n        rawToprfEncryptionKey: encKey,\n        rawToprfAuthKeyPair: authKeyPair,\n      });\n    }\n\n    return secretData;\n  }\n\n  /**\n   * @description Update the password of the seedless onboarding flow.\n   *\n   * Changing password will also update the encryption key and metadata store with new encrypted values.\n   *\n   * @param params - The parameters for updating the password.\n   * @param params.verifierID - The deterministic identifier of the user from the login provider.\n   * @param params.verifier - The login provider of the user.\n   * @param params.newPassword - The new password to update.\n   * @param params.oldPassword - The old password to verify.\n   */\n  async updatePassword(params: UpdatePasswordParams) {\n    const { verifier, verifierID, newPassword, oldPassword } = params;\n\n    // 1. unlock the encrypted vault with old password, retrieve the ek and authTokens from the vault\n    const { nodeAuthTokens, toprfEncryptionKey, toprfAuthKeyPair } =\n      await this.#unlockVault(oldPassword);\n    // 2. call changePassword method from Toprf Client with old password, new password\n    const { encKey: newEncKey, authKeyPair: newAuthKeyPair } =\n      await this.toprfAuthClient.changeEncKey({\n        nodeAuthTokens,\n        verifier,\n        verifierID,\n        oldEncKey: toprfEncryptionKey,\n        oldAuthKeyPair: toprfAuthKeyPair,\n        password: newPassword,\n      });\n\n    // 3. update and encrypt the vault with new password\n    await this.#createNewVaultWithAuthData({\n      password: newPassword,\n      authTokens: nodeAuthTokens,\n      rawToprfEncryptionKey: newEncKey,\n      rawToprfAuthKeyPair: newAuthKeyPair,\n    });\n  }\n\n  /**\n   * @description Get the node auth tokens from the state.\n   * @returns The node auth tokens.\n   */\n  #getNodeAuthTokens() {\n    const { nodeAuthTokens } = this.state;\n    if (!nodeAuthTokens) {\n      throw new Error(SeedlessOnboardingControllerError.NoOAuthIdToken);\n    }\n    return nodeAuthTokens;\n  }\n\n  async #unlockVault(password: string): Promise<{\n    nodeAuthTokens: NodeAuthTokens;\n    toprfEncryptionKey: Uint8Array;\n    toprfAuthKeyPair: KeyPair;\n  }> {\n    return this.#withVaultLock(async () => {\n      assertIsValidPassword(password);\n\n      const encryptedVault = this.state.vault;\n      if (!encryptedVault) {\n        throw new Error(SeedlessOnboardingControllerError.VaultError);\n      }\n\n      const decryptedVaultData = await this.#encryptor.decrypt(\n        password,\n        encryptedVault,\n      );\n\n      return this.#parseVaultData(decryptedVaultData);\n    });\n  }\n\n  async #createNewVaultWithAuthData({\n    password,\n    authTokens,\n    rawToprfEncryptionKey,\n    rawToprfAuthKeyPair,\n  }: {\n    password: string;\n    authTokens: NodeAuthTokens;\n    rawToprfEncryptionKey: Uint8Array;\n    rawToprfAuthKeyPair: KeyPair;\n  }): Promise<void> {\n    const { toprfEncryptionKey, toprfAuthKeyPair } =\n      await this.#serializeKeyData(rawToprfEncryptionKey, rawToprfAuthKeyPair);\n\n    await this.#updateVault({\n      password,\n      vaultData: {\n        authTokens,\n        toprfEncryptionKey,\n        toprfAuthKeyPair,\n      },\n    });\n  }\n\n  async #updateVault({\n    password,\n    vaultData,\n  }: {\n    password: string;\n    vaultData: object;\n  }): Promise<boolean> {\n    return this.#withVaultLock(async () => {\n      assertIsValidPassword(password);\n\n      const serializedStateData = await this.#getSerializedStateData(vaultData);\n\n      const updatedState: Partial<SeedlessOnboardingControllerState> = {};\n\n      updatedState.vault = await this.#encryptor.encrypt(\n        password,\n        serializedStateData,\n      );\n\n      this.update((state) => {\n        state.vault = updatedState.vault;\n      });\n\n      return true;\n    });\n  }\n\n  /**\n   * Lock the vault mutex before executing the given function,\n   * and release it after the function is resolved or after an\n   * error is thrown.\n   *\n   * This ensures that each operation that interacts with the vault\n   * is executed in a mutually exclusive way.\n   *\n   * @param callback - The function to execute while the vault mutex is locked.\n   * @returns The result of the function.\n   */\n  async #withVaultLock<Result>(\n    callback: MutuallyExclusiveCallback<Result>,\n  ): Promise<Result> {\n    return withLock(this.#vaultOperationMutex, callback);\n  }\n\n  async #getSerializedStateData(data: object): Promise<string> {\n    return JSON.stringify(data);\n  }\n\n  /**\n   * @description Serialize the encryption key and authentication key pair.\n   * @param encKey - The encryption key to serialize.\n   * @param authKeyPair - The authentication key pair to serialize.\n   * @returns The serialized encryption key and authentication key pair.\n   */\n  async #serializeKeyData(\n    encKey: Uint8Array,\n    authKeyPair: KeyPair,\n  ): Promise<{\n    toprfEncryptionKey: string;\n    toprfAuthKeyPair: string;\n  }> {\n    const b64EncodedEncKey = Buffer.from(encKey).toString('base64');\n    const b64EncodedAuthKeyPair = JSON.stringify({\n      sk: authKeyPair.sk.toString(),\n      pk: Buffer.from(authKeyPair.pk).toString('base64'),\n    });\n\n    return {\n      toprfEncryptionKey: b64EncodedEncKey,\n      toprfAuthKeyPair: b64EncodedAuthKeyPair,\n    };\n  }\n\n  async #parseVaultData(data: unknown): Promise<{\n    nodeAuthTokens: NodeAuthTokens;\n    toprfEncryptionKey: Uint8Array;\n    toprfAuthKeyPair: KeyPair;\n  }> {\n    if (typeof data !== 'string') {\n      throw new Error(SeedlessOnboardingControllerError.VaultDataError);\n    }\n\n    const parsedVaultData = JSON.parse(data);\n\n    if (\n      !('authTokens' in parsedVaultData) ||\n      !('toprfEncryptionKey' in parsedVaultData) ||\n      !('toprfAuthKeyPair' in parsedVaultData)\n    ) {\n      throw new Error(SeedlessOnboardingControllerError.VaultDataError);\n    }\n\n    const rawToprfEncryptionKey = new Uint8Array(\n      Buffer.from(parsedVaultData.toprfEncryptionKey, 'base64'),\n    );\n    const parsedToprfAuthKeyPair = JSON.parse(parsedVaultData.toprfAuthKeyPair);\n    const rawToprfAuthKeyPair = {\n      sk: BigInt(parsedToprfAuthKeyPair.sk),\n      pk: new Uint8Array(Buffer.from(parsedToprfAuthKeyPair.pk, 'base64')),\n    };\n\n    return {\n      nodeAuthTokens: parsedVaultData.authTokens,\n      toprfEncryptionKey: rawToprfEncryptionKey,\n      toprfAuthKeyPair: rawToprfAuthKeyPair,\n    };\n  }\n}\n\n/**\n * Assert that the provided password is a valid non-empty string.\n *\n * @param password - The password to check.\n * @throws If the password is not a valid string.\n */\nfunction assertIsValidPassword(password: unknown): asserts password is string {\n  if (typeof password !== 'string') {\n    throw new Error(SeedlessOnboardingControllerError.WrongPasswordType);\n  }\n\n  if (!password || !password.length) {\n    throw new Error(SeedlessOnboardingControllerError.InvalidEmptyPassword);\n  }\n}\n\n/**\n * Lock the given mutex before executing the given function,\n * and release it after the function is resolved or after an\n * error is thrown.\n *\n * @param mutex - The mutex to lock.\n * @param callback - The function to execute while the mutex is locked.\n * @returns The result of the function.\n */\nasync function withLock<Result>(\n  mutex: Mutex,\n  callback: MutuallyExclusiveCallback<Result>,\n): Promise<Result> {\n  const releaseLock = await mutex.acquire();\n\n  try {\n    return await callback({ releaseLock });\n  } finally {\n    releaseLock();\n  }\n}\n"]}