{"version":3,"file":"types.mjs","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"","sourcesContent":["import type {\n  KeyDerivationOptions,\n  EncryptionKey,\n  EncryptionResult,\n} from '@metamask/browser-passworder';\n\nexport type OAuthVerifier = 'google' | 'apple';\n\nexport type AuthenticateUserParams = {\n  idTokens: string[];\n  verifier: OAuthVerifier;\n  verifierID: string;\n  indexes: number[];\n  endpoints: string[];\n};\n\nexport type NodeAuthToken = {\n  /**\n   * The token issued by the node on verifying the idToken\n   */\n  nodeAuthToken: string;\n  /**\n   * The index of the node that issued the token\n   */\n  nodeIndex: number;\n};\n\nexport type NodeAuthTokens = NodeAuthToken[];\n\nexport type CreateSeedlessBackupParams = {\n  password: string;\n  seedPhrase: string;\n};\n\nexport type RestoreSeedlessBackupParams = {\n  nodeAuthTokens: NodeAuthTokens;\n  password: string;\n  seedPhrase: string;\n};\n\nexport type Encryptor = {\n  /**\n   * @description Remove this method once the TOPRF lib is ready.\n   * Encryption key should be generated using the TOPRF lib.\n   * Generates a key from a password.\n   *\n   * @param password - The password to use for key generation.\n   * @param salt - The salt to use for key generation.\n   * @param exportable - Whether the key should be exportable.\n   * @param opts - The options for key generation.\n   * @returns A promise that resolves to the key.\n   */\n  keyFromPassword: (\n    password: string,\n    salt?: string,\n    exportable?: boolean,\n    opts?: KeyDerivationOptions,\n  ) => Promise<CryptoKey | EncryptionKey>;\n\n  /**\n   * Encrypts a data string using a key.\n   *\n   * @param key - The key to use for encryption.\n   * @param data - The data to encrypt.\n   * @returns A promise that resolves to the encrypted data.\n   */\n  encryptWithKey: (\n    key: CryptoKey | EncryptionKey,\n    data: string,\n  ) => Promise<EncryptionResult>;\n\n  /**\n   * Decrypts an encrypted data using a key.\n   *\n   * @param key - The key to use for decryption.\n   * @param encryptedData - The encrypted data to decrypt.\n   * @returns A promise that resolves to the decrypted data.\n   */\n  decryptWithKey: (\n    key: CryptoKey | EncryptionKey,\n    encryptedData: EncryptionResult,\n  ) => Promise<string>;\n\n  /**\n   * Generates an encryption key from exported key string.\n   *\n   * @param key - The exported key string.\n   * @returns The encryption key.\n   */\n  importKey: (key: string) => Promise<CryptoKey | EncryptionKey>;\n\n  /**\n   * Exports a key to an exported key string.\n   *\n   * @param key - The key to export.\n   * @returns The exported key string.\n   */\n  exportKey: (key: CryptoKey | EncryptionKey) => Promise<string>;\n\n  /**\n   * Generates a random salt.\n   *\n   * @returns the random salt string.\n   */\n  generateSalt?: () => string;\n};\n"]}