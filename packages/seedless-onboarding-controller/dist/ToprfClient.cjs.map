{"version":3,"file":"ToprfClient.cjs","sourceRoot":"","sources":["../src/ToprfClient.ts"],"names":[],"mappings":"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","sourcesContent":["import type { EncryptionResult } from '@metamask/browser-passworder';\n\nimport type { Encryptor, NodeAuthTokens } from './types';\n\nexport type AuthenticationParams = {\n  // for now we only support one idToken, in future we will support multiple to remove commitment call\n  // so leaving it as an array for future use\n  idTokens: string[];\n  endpoints: string[];\n  indexes: number[];\n  verifier: string;\n  verifierID: string;\n};\n\nexport type AuthenticationResult = {\n  /**\n   * The tokens issued by the nodes on verifying the idTokens\n   */\n  nodeAuthTokens: NodeAuthTokens;\n  /**\n   * The public key of the share if the user is an existing user\n   */\n  existingEncKeyPublicData?: {\n    pubKeyX: string;\n    pubKeyY: string;\n    keyIndex: number;\n  };\n  /**\n   * Whether the user is an existing user\n   */\n  hasValidEncKey: boolean;\n};\n\nexport type CreateEncKeyParams = {\n  /**\n   * The tokens issued by the nodes on verifying the idToken.\n   */\n  nodeAuthTokens: NodeAuthTokens;\n  /**\n   * The password of the user.\n   */\n  password: string;\n};\n\nexport type CreateEncKeyResult = {\n  /**\n   * The encryption key which is used to decrypt the secret data. This key is\n   * generated by client and threshold shared with the nodes using TOPRF\n   * protocol.\n   */\n  encKey: string;\n};\n\nexport type StoreSecretDataParams = {\n  /**\n   * The tokens issued by the nodes on verifying the idTokens\n   */\n  nodeAuthTokens: NodeAuthTokens;\n  /**\n   * The encryption key under which the secret data will be encrypted.\n   */\n  encKey: string;\n  /**\n   * The secret data in hex encoding.\n   */\n  secretData: string;\n};\n\nexport type StoreSecretDataResult = {\n  /**\n   * The encryption key which is used to decrypt the secret data.\n   * This key is generated by client and threshold shared with the nodes using TOPRF protocol.\n   */\n  encKey: string;\n  /**\n   * The encrypted secret data\n   */\n  encryptedSecretData: string;\n};\n\nexport type FetchSecretDataParams = {\n  /**\n   * The tokens issued by the nodes on verifying the idToken.\n   */\n  nodeAuthTokens: NodeAuthTokens;\n  /**\n   * The password of the user.\n   */\n  password: string;\n};\n\nexport type FetchSecretDataResult = {\n  /**\n   * The encryption key which is used to decrypt the secret data.\n   * This key is generated by client and threshold shared with the nodes using TOPRF protocol.\n   */\n  encKey: string;\n  /**\n   * The secret data to be fetched\n   */\n  secretData: string[] | null;\n};\n\n// TODO: remove this store, this is only used for mocking the toprf-sdk before it's ready\nclass Store {\n  async set(key: string, value: string) {\n    const response = await fetch('http://localhost:8080/set', {\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      method: 'POST',\n      body: JSON.stringify({ key, value }),\n    });\n    if (!response.ok) {\n      throw new Error('Failed to set value');\n    }\n  }\n\n  async get(key: string): Promise<string | undefined> {\n    const response = await fetch('http://localhost:8080/get', {\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      method: 'POST',\n      body: JSON.stringify({ key }),\n    });\n    if (!response.ok) {\n      throw new Error('Failed to get value');\n    }\n    const data = await response.json();\n    return data.value;\n  }\n}\n\n// TODO: remove the class once the toprf-sdk is ready\n// This class is a mock implementation for the toprf-sdk\nexport class ToprfAuthClient {\n  readonly #mockAuthStore: Store = new Store();\n\n  readonly #mockMetadataStore: Store = new Store();\n\n  // TODO: remove this once the toprf-sdk is ready\n  // encryptions/signings should be done in the toprf-sdk\n  readonly #encryptor: Encryptor;\n\n  constructor(encryptor: Encryptor) {\n    this.#encryptor = encryptor;\n  }\n\n  /**\n   * Mock implementation of the authenticate method\n   *\n   * @param params - The parameters for the authentication\n   * @returns The authentication result\n   */\n  async authenticate(\n    params: AuthenticationParams,\n  ): Promise<AuthenticationResult> {\n    const key = `auth_${params.verifier}:${params.verifierID}`;\n    const stringifiedNodeAuthTokens = await this.#mockAuthStore.get(key);\n    const hasValidEncKey = Boolean(stringifiedNodeAuthTokens);\n    let nodeAuthTokens: NodeAuthTokens;\n\n    if (stringifiedNodeAuthTokens === undefined) {\n      // generate mock nodeAuthTokens\n      nodeAuthTokens = Array.from(\n        { length: params.indexes.length },\n        (_, index) => ({\n          nodeAuthToken: `nodeAuthToken-${index}-${params.verifier}-${params.verifierID}`,\n          nodeIndex: params.indexes[index],\n        }),\n      );\n      await this.#mockAuthStore.set(key, JSON.stringify(nodeAuthTokens));\n    } else {\n      nodeAuthTokens = JSON.parse(stringifiedNodeAuthTokens);\n    }\n    // TODO: do the threshold check\n\n    return {\n      nodeAuthTokens,\n      hasValidEncKey,\n    };\n  }\n\n  /**\n   * Mock implementation of the createEncKey method\n   * This method derives the encryption key from the password with Threshold OPRF\n   *\n   * @param params - The parameters for the createEncKey\n   * @returns The createEncKey result\n   */\n  async createEncKey(params: CreateEncKeyParams): Promise<CreateEncKeyResult> {\n    // NOTE: this is a mock implementation\n    // actual implementation involves threshold oprf\n    const salt = 'SALT';\n    const cryptoKey = await this.#encryptor.keyFromPassword(\n      params.password,\n      salt,\n    );\n    const key = 'key' in cryptoKey ? cryptoKey.key : cryptoKey;\n    const encKey = await this.#encryptor.exportKey(key);\n\n    return {\n      encKey,\n    };\n  }\n\n  async storeSecretData(\n    params: StoreSecretDataParams,\n  ): Promise<StoreSecretDataResult> {\n    const { nodeAuthTokens, encKey, secretData } = params;\n\n    const encryptedSecretData = await this.#encryptSecretData(\n      encKey,\n      secretData,\n    );\n\n    const key = nodeAuthTokens.reduce(\n      (acc, token) => `${acc}:${token.nodeAuthToken}`,\n      'metadata_',\n    );\n    await this.#mockMetadataStore.set(key, encryptedSecretData);\n\n    return {\n      encKey,\n      encryptedSecretData,\n    };\n  }\n\n  async fetchSecretData(\n    params: FetchSecretDataParams,\n  ): Promise<FetchSecretDataResult> {\n    const { encKey } = await this.createEncKey(params);\n\n    const key = params.nodeAuthTokens.reduce(\n      (acc, token) => `${acc}:${token.nodeAuthToken}`,\n      'metadata_',\n    );\n    const encryptedSecretData = await this.#mockMetadataStore.get(key);\n\n    const secretData = encryptedSecretData\n      ? await this.#decryptSecretData(encKey, encryptedSecretData)\n      : null;\n\n    return {\n      encKey,\n      secretData: secretData ? [secretData] : null,\n    };\n  }\n\n  async #encryptSecretData(\n    encKeyString: string,\n    secretData: string,\n  ): Promise<string> {\n    const encryptionKey = await this.#encryptor.importKey(encKeyString);\n    const encryptedSecretData = await this.#encryptor.encryptWithKey(\n      encryptionKey,\n      secretData,\n    );\n\n    return JSON.stringify(encryptedSecretData);\n  }\n\n  async #decryptSecretData(\n    encKeyString: string,\n    encryptedSecretData: string,\n  ): Promise<string> {\n    let encryptedResult: EncryptionResult;\n    try {\n      encryptedResult = JSON.parse(encryptedSecretData) as EncryptionResult;\n    } catch (error: unknown) {\n      console.error(error);\n      throw new Error('Fail to encrypt. Invalid data');\n    }\n    const decryptionKey = await this.#encryptor.importKey(encKeyString);\n    const decryptedResult = await this.#encryptor.decryptWithKey(\n      decryptionKey,\n      encryptedResult,\n    );\n\n    return decryptedResult as string;\n  }\n}\n"]}