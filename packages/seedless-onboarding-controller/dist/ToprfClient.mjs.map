{"version":3,"file":"ToprfClient.mjs","sourceRoot":"","sources":["../src/ToprfClient.ts"],"names":[],"mappings":"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","sourcesContent":["import { EncryptorDecryptor } from './encryption';\nimport { MetadataStore } from './MetadataStore';\nimport type { NodeAuthTokens } from './types';\n\nexport type AuthenticationParams = {\n  // for now we only support one idToken, in future we will support multiple to remove commitment call\n  // so leaving it as an array for future use\n  idTokens: string[];\n  endpoints: string[];\n  indexes: number[];\n  verifier: string;\n  verifierID: string;\n};\n\nexport type AuthenticationResult = {\n  /**\n   * The tokens issued by the nodes on verifying the idTokens\n   */\n  nodeAuthTokens: NodeAuthTokens;\n  /**\n   * The public key of the share if the user is an existing user\n   */\n  existingEncKeyPublicData?: {\n    pubKeyX: string;\n    pubKeyY: string;\n    keyIndex: number;\n  };\n  /**\n   * Whether the user is an existing user\n   */\n  hasValidEncKey: boolean;\n};\n\nexport type CreateEncKeyParams = {\n  /**\n   * The tokens issued by the nodes on verifying the idToken.\n   */\n  nodeAuthTokens: NodeAuthTokens;\n  /**\n   * The password of the user.\n   */\n  password: string;\n};\n\nexport type CreateEncKeyResult = {\n  /**\n   * The encryption key which is used to decrypt the secret data. This key is\n   * generated by client and threshold shared with the nodes using TOPRF\n   * protocol.\n   */\n  encKey: string;\n};\n\nexport type StoreSecretDataParams = {\n  /**\n   * The tokens issued by the nodes on verifying the idTokens\n   */\n  nodeAuthTokens: NodeAuthTokens;\n  /**\n   * The encryption key under which the secret data will be encrypted.\n   */\n  encKey: string;\n  /**\n   * The secret data in hex encoding.\n   */\n  secretData: string;\n};\n\nexport type StoreSecretDataResult = {\n  /**\n   * The encryption key which is used to decrypt the secret data.\n   * This key is generated by client and threshold shared with the nodes using TOPRF protocol.\n   */\n  encKey: string;\n  /**\n   * The encrypted secret data\n   */\n  encryptedSecretData: string;\n};\n\nexport type FetchSecretDataParams = {\n  /**\n   * The tokens issued by the nodes on verifying the idToken.\n   */\n  nodeAuthTokens: NodeAuthTokens;\n  /**\n   * The password of the user.\n   */\n  password: string;\n};\n\nexport type FetchSecretDataResult = {\n  /**\n   * The encryption key which is used to decrypt the secret data.\n   * This key is generated by client and threshold shared with the nodes using TOPRF protocol.\n   */\n  encKey: string;\n  /**\n   * The secret data to be fetched\n   */\n  secretData: string[] | null;\n};\n\n// TODO: remove the class once the toprf-sdk is ready\n// This class is a mock implementation for the toprf-sdk\nexport class ToprfAuthClient {\n  readonly #mockAuthStore: MetadataStore = new MetadataStore('auth');\n\n  readonly #mockMetadataStore: MetadataStore = new MetadataStore('metadata');\n\n  // TODO: remove this once the toprf-sdk is ready\n  // encryptions/signings should be done in the toprf-sdk\n  readonly #encryptor: EncryptorDecryptor;\n\n  constructor() {\n    this.#encryptor = new EncryptorDecryptor();\n  }\n\n  /**\n   * Mock implementation of the authenticate method\n   *\n   * @param params - The parameters for the authentication\n   * @returns The authentication result\n   */\n  async authenticate(\n    params: AuthenticationParams,\n  ): Promise<AuthenticationResult> {\n    const key = `${params.verifier}:${params.verifierID}`;\n    const stringifiedNodeAuthTokens = await this.#mockAuthStore.get(key);\n    const hasValidEncKey = Boolean(stringifiedNodeAuthTokens);\n    let nodeAuthTokens: NodeAuthTokens;\n\n    if (\n      stringifiedNodeAuthTokens === undefined ||\n      stringifiedNodeAuthTokens === null\n    ) {\n      // generate mock nodeAuthTokens\n      nodeAuthTokens = Array.from(\n        { length: params.indexes.length },\n        (_, index) => ({\n          nodeAuthToken: `nodeAuthToken-${index}-${params.verifier}-${params.verifierID}`,\n          nodeIndex: params.indexes[index],\n        }),\n      );\n      await this.#mockAuthStore.set(key, JSON.stringify(nodeAuthTokens));\n    } else {\n      nodeAuthTokens = JSON.parse(stringifiedNodeAuthTokens);\n    }\n    // TODO: do the threshold check\n\n    return {\n      nodeAuthTokens,\n      hasValidEncKey,\n    };\n  }\n\n  /**\n   * Mock implementation of the createEncKey method\n   * This method derives the encryption key from the password with Threshold OPRF\n   *\n   * @param params - The parameters for the createEncKey\n   * @returns The createEncKey result\n   */\n  async createEncKey(params: CreateEncKeyParams): Promise<CreateEncKeyResult> {\n    const encKey = this.#encryptor.keyFromPassword(params.password);\n    return {\n      encKey,\n    };\n  }\n\n  async storeSecretData(\n    params: StoreSecretDataParams,\n  ): Promise<StoreSecretDataResult> {\n    const { nodeAuthTokens, encKey, secretData } = params;\n\n    const encryptedSecretData = this.#encryptor.encrypt(encKey, secretData);\n\n    console.log('encryptedSecretData', encryptedSecretData);\n\n    const key = nodeAuthTokens.reduce(\n      (acc, token) => `${acc}:${token.nodeAuthToken}`,\n      '',\n    );\n    await this.#mockMetadataStore.set(key, encryptedSecretData);\n\n    return {\n      encKey,\n      encryptedSecretData,\n    };\n  }\n\n  async fetchSecretData(\n    params: FetchSecretDataParams,\n  ): Promise<FetchSecretDataResult> {\n    const { encKey } = await this.createEncKey(params);\n    console.log('encKey', encKey);\n\n    const key = params.nodeAuthTokens.reduce(\n      (acc, token) => `${acc}:${token.nodeAuthToken}`,\n      '',\n    );\n    const encryptedSecretData = await this.#mockMetadataStore.get(key);\n    console.log('encryptedSecretData', encryptedSecretData);\n\n    const secretData = encryptedSecretData\n      ? this.#encryptor.decrypt(encKey, encryptedSecretData)\n      : null;\n\n    return {\n      encKey,\n      secretData: secretData ? [secretData] : null,\n    };\n  }\n}\n"]}