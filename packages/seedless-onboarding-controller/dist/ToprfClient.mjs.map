{"version":3,"file":"ToprfClient.mjs","sourceRoot":"","sources":["../src/ToprfClient.ts"],"names":[],"mappings":"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","sourcesContent":["import { EncryptorDecryptor } from './encryption';\nimport { MetadataStore } from './MetadataStore';\nimport type { NodeAuthTokens } from './types';\n\nexport type AuthenticationParams = {\n  // for now we only support one idToken, in future we will support multiple to remove commitment call\n  // so leaving it as an array for future use\n  idTokens: string[];\n  endpoints: string[];\n  indexes: number[];\n  verifier: string;\n  verifierID: string;\n};\n\nexport type AuthenticationResult = {\n  /**\n   * The tokens issued by the nodes on verifying the idTokens\n   */\n  nodeAuthTokens: NodeAuthTokens;\n  /**\n   * The public key of the share if the user is an existing user\n   */\n  existingEncKeyPublicData?: {\n    pubKeyX: string;\n    pubKeyY: string;\n    keyIndex: number;\n  };\n  /**\n   * Whether the user is an existing user\n   */\n  hasValidEncKey: boolean;\n};\n\nexport type CreateEncKeyParams = {\n  /**\n   * The tokens issued by the nodes on verifying the idToken.\n   */\n  nodeAuthTokens: NodeAuthTokens;\n  /**\n   * The login provider of the user.\n   */\n  verifier: string;\n  /**\n   * The deterministic identifier of the user from the login provider.\n   */\n  verifierID: string;\n  /**\n   * The password of the user.\n   */\n  password: string;\n};\n\nexport type CreateEncKeyResult = {\n  /**\n   * The encryption key which is used to decrypt the secret data. This key is\n   * generated by client and threshold shared with the nodes using TOPRF\n   * protocol.\n   */\n  encKey: string;\n};\n\nexport type StoreSecretDataParams = {\n  /**\n   * The tokens issued by the nodes on verifying the idTokens\n   */\n  nodeAuthTokens: NodeAuthTokens;\n  /**\n   * The encryption key under which the secret data will be encrypted.\n   */\n  encKey: string;\n  /**\n   * The secret data in hex encoding.\n   */\n  secretData: string;\n};\n\nexport type StoreSecretDataResult = {\n  /**\n   * The encryption key which is used to decrypt the secret data.\n   * This key is generated by client and threshold shared with the nodes using TOPRF protocol.\n   */\n  encKey: string;\n  /**\n   * The encrypted secret data\n   */\n  encryptedSecretData: string;\n};\n\nexport type FetchSecretDataParams = {\n  /**\n   * The tokens issued by the nodes on verifying the idToken.\n   */\n  nodeAuthTokens: NodeAuthTokens;\n  /**\n   * The key to decrypt the secret data.\n   */\n  encKey: string;\n};\n\nexport type FetchSecretDataResult = {\n  /**\n   * The encryption key which is used to decrypt the secret data.\n   * This key is generated by client and threshold shared with the nodes using TOPRF protocol.\n   */\n  encKey: string;\n  /**\n   * The secret data to be fetched\n   */\n  secretData: string[] | null;\n};\n\n// TODO: remove the class once the toprf-sdk is ready\n// This class is a mock implementation for the toprf-sdk\nexport class ToprfAuthClient {\n  readonly #mockAuthStore: MetadataStore = new MetadataStore('auth');\n\n  readonly #mockMetadataStore: MetadataStore = new MetadataStore('metadata');\n\n  // TODO: remove this once the toprf-sdk is ready\n  // encryptions/signings should be done in the toprf-sdk\n  readonly #encryptor: EncryptorDecryptor;\n\n  constructor() {\n    this.#encryptor = new EncryptorDecryptor();\n  }\n\n  /**\n   * Mock implementation of the authenticate method\n   *\n   * @param params - The parameters for the authentication\n   * @returns The authentication result\n   */\n  async authenticate(\n    params: AuthenticationParams,\n  ): Promise<AuthenticationResult> {\n    const key = `${params.verifier}:${params.verifierID}`;\n    const authenticationResult = await this.#mockAuthStore.get(key);\n    let hasValidEncKey = false;\n    let nodeAuthTokens: NodeAuthTokens;\n\n    const isValidAuthResponse = this.#isValidAuthResponse(authenticationResult);\n    if (authenticationResult === undefined || !isValidAuthResponse) {\n      // generate mock nodeAuthTokens\n      nodeAuthTokens = Array.from(\n        { length: params.indexes.length },\n        (_, index) => ({\n          nodeAuthToken: `nodeAuthToken-${index}-${params.verifier}-${params.verifierID}`,\n          nodeIndex: params.indexes[index],\n        }),\n      );\n      const data = JSON.stringify({\n        nodeAuthTokens,\n        hasValidEncKey,\n      });\n      await this.#mockAuthStore.set(key, data);\n    } else {\n      const parsedAuthenticationResult = JSON.parse(authenticationResult);\n      nodeAuthTokens = parsedAuthenticationResult.nodeAuthTokens;\n      hasValidEncKey = Boolean(parsedAuthenticationResult.hasValidEncKey);\n    }\n\n    return {\n      nodeAuthTokens,\n      hasValidEncKey,\n    };\n  }\n\n  /**\n   * Mock implementation of the createEncKey method\n   * This method derives the encryption key from the password with Threshold OPRF\n   *\n   * @param params - The parameters for the createEncKey\n   * @returns The createEncKey result\n   */\n  async createEncKey(params: CreateEncKeyParams): Promise<CreateEncKeyResult> {\n    const key = `${params.verifier}:${params.verifierID}`;\n    const data = JSON.stringify({\n      nodeAuthTokens: params.nodeAuthTokens,\n      hasValidEncKey: true,\n    });\n    await this.#mockAuthStore.set(key, data);\n\n    const encKey = this.#encryptor.keyFromPassword(params.password);\n    return {\n      encKey,\n    };\n  }\n\n  async storeSecretData(\n    params: StoreSecretDataParams,\n  ): Promise<StoreSecretDataResult> {\n    const { nodeAuthTokens, encKey, secretData } = params;\n\n    const encryptedSecretData = this.#encryptor.encrypt(encKey, secretData);\n\n    const key = nodeAuthTokens.reduce(\n      (acc, token) => `${acc}:${token.nodeAuthToken}`,\n      '',\n    );\n    await this.#mockMetadataStore.set(key, encryptedSecretData);\n\n    return {\n      encKey,\n      encryptedSecretData,\n    };\n  }\n\n  async fetchSecretData(\n    params: FetchSecretDataParams,\n  ): Promise<FetchSecretDataResult> {\n    const key = params.nodeAuthTokens.reduce(\n      (acc, token) => `${acc}:${token.nodeAuthToken}`,\n      '',\n    );\n    const encryptedSecretData = await this.#mockMetadataStore.get(key);\n\n    const secretData = encryptedSecretData\n      ? this.#encryptor.decrypt(params.encKey, encryptedSecretData)\n      : null;\n\n    return {\n      encKey: params.encKey,\n      secretData: secretData ? [secretData] : null,\n    };\n  }\n\n  #isValidAuthResponse(authResponse: string | null | undefined): boolean {\n    if (authResponse === undefined || authResponse === null) {\n      return false;\n    }\n\n    const parsedAuthResponse = JSON.parse(authResponse);\n\n    return parsedAuthResponse.nodeAuthTokens !== undefined;\n  }\n}\n"]}