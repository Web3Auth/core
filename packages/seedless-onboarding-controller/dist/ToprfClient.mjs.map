{"version":3,"file":"ToprfClient.mjs","sourceRoot":"","sources":["../src/ToprfClient.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,OAAO,EAAE,UAAU,EAAE,wBAAwB;AAE7C,OAAO,EAAE,iCAAiC,EAAE,wBAAoB;AAChE,OAAO,EAAE,kBAAkB,EAAE,yBAAqB;AAClD,OAAO,EAAE,aAAa,EAAE,4BAAwB;AA4NhD,qDAAqD;AACrD,wDAAwD;AACxD,MAAM,OAAO,eAAe;IAS1B;;QARS,yCAAgC,IAAI,aAAa,CAAC,MAAM,CAAC,EAAC;QAE1D,6CAAoC,IAAI,aAAa,CAAC,UAAU,CAAC,EAAC;QAE3E,gDAAgD;QAChD,uDAAuD;QAC9C,6CAA+B;QAGtC,uBAAA,IAAI,8BAAc,IAAI,kBAAkB,EAAE,MAAA,CAAC;IAC7C,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,YAAY,CAChB,MAA4B;QAE5B,MAAM,GAAG,GAAG,GAAG,MAAM,CAAC,QAAQ,IAAI,MAAM,CAAC,UAAU,EAAE,CAAC;QACtD,MAAM,oBAAoB,GAAG,MAAM,uBAAA,IAAI,sCAAe,CAAC,GAAG,CAAS,GAAG,CAAC,CAAC;QACxE,IAAI,cAAc,GAAG,KAAK,CAAC;QAC3B,IAAI,cAA8B,CAAC;QAEnC,MAAM,mBAAmB,GAAG,uBAAA,IAAI,wEAAqB,MAAzB,IAAI,EAAsB,oBAAoB,CAAC,CAAC;QAC5E,IAAI,oBAAoB,KAAK,SAAS,IAAI,CAAC,mBAAmB,EAAE;YAC9D,+BAA+B;YAC/B,cAAc,GAAG,uBAAA,IAAI,+EAA4B,MAAhC,IAAI,EACnB,MAAM,CAAC,QAAQ,EACf,MAAM,CAAC,UAAU,CAClB,CAAC;YACF,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC;gBAC1B,cAAc;gBACd,cAAc;aACf,CAAC,CAAC;YACH,MAAM,uBAAA,IAAI,sCAAe,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;SAC1C;aAAM;YACL,MAAM,0BAA0B,GAAG,IAAI,CAAC,KAAK,CAAC,oBAAoB,CAAC,CAAC;YACpE,cAAc,GAAG,0BAA0B,CAAC,cAAc,CAAC;YAC3D,cAAc,GAAG,OAAO,CAAC,0BAA0B,CAAC,cAAc,CAAC,CAAC;SACrE;QAED,OAAO;YACL,cAAc;YACd,cAAc;SACf,CAAC;IACJ,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,YAAY,CAAC,MAA0B;QAC3C,MAAM,GAAG,GAAG,GAAG,MAAM,CAAC,QAAQ,IAAI,MAAM,CAAC,UAAU,EAAE,CAAC;QACtD,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC;YAC1B,cAAc,EAAE,MAAM,CAAC,cAAc;YACrC,cAAc,EAAE,IAAI;SACrB,CAAC,CAAC;QACH,MAAM,uBAAA,IAAI,sCAAe,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QAEzC,MAAM,MAAM,GAAG,uBAAA,IAAI,kCAAW,CAAC,eAAe,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAEhE,MAAM,WAAW,GAAG,uBAAA,IAAI,kCAAW,CAAC,uBAAuB,CACzD,MAAM,CAAC,QAAQ,CAChB,CAAC;QACF,OAAO;YACL,MAAM;YACN,WAAW;SACZ,CAAC;IACJ,CAAC;IAED;;;;;;;;;OASG;IACH,KAAK,CAAC,YAAY,CAChB,MAAiC;QAEjC,IAAI;YACF,MAAM,GAAG,GAAG,GAAG,MAAM,CAAC,QAAQ,IAAI,MAAM,CAAC,UAAU,EAAE,CAAC;YACtD,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC;gBAC1B,cAAc,EAAE,MAAM,CAAC,cAAc;gBACrC,cAAc,EAAE,IAAI;aACrB,CAAC,CAAC;YACH,MAAM,uBAAA,IAAI,sCAAe,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;YAEzC,MAAM,MAAM,GAAG,uBAAA,IAAI,kCAAW,CAAC,eAAe,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;YAChE,MAAM,WAAW,GAAG,uBAAA,IAAI,kCAAW,CAAC,uBAAuB,CACzD,MAAM,CAAC,QAAQ,CAChB,CAAC;YACF,OAAO;gBACL,MAAM;gBACN,WAAW;aACZ,CAAC;SACH;QAAC,OAAO,CAAC,EAAE;YACV,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,iBAAiB,CAAC,CAAC;SACtE;IACH,CAAC;IAED;;;;;;;;;OASG;IACH,KAAK,CAAC,iBAAiB,CAAC,MAA+B;QACrD,MAAM,EAAE,MAAM,EAAE,UAAU,EAAE,GAAG,MAAM,CAAC;QAEtC,MAAM,mBAAmB,GAAG,uBAAA,IAAI,kCAAW,CAAC,OAAO,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;QAExE,MAAM,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;QACjD,MAAM,uBAAA,IAAI,0CAAmB,CAAC,GAAG,CAAC,MAAM,EAAE,mBAAmB,CAAC,CAAC;IACjE,CAAC;IAED;;;;;;;;;;OAUG;IACH,KAAK,CAAC,kBAAkB,CACtB,MAAgC;QAEhC,MAAM,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;QACjD,MAAM,mBAAmB,GACvB,CAAC,MAAM,uBAAA,IAAI,0CAAmB,CAAC,GAAG,CAAW,MAAM,CAAC,CAAC,IAAI,EAAE,CAAC;QAE9D,MAAM,UAAU,GAAiB,EAAE,CAAC;QACpC,IAAI;YACF,MAAM,mBAAmB,GAAG,mBAAmB,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE;gBAC3D,MAAM,OAAO,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;gBAC5D,OAAO,uBAAA,IAAI,kCAAW,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;YACzD,CAAC,CAAC,CAAC;YACH,UAAU,CAAC,IAAI,CAAC,GAAG,mBAAmB,CAAC,CAAC;SACzC;QAAC,OAAO,CAAC,EAAE;YACV,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,iBAAiB,CAAC,CAAC;SACtE;QAED,OAAO,UAAU,CAAC;IACpB,CAAC;CAoBF;iRAlBsB,YAAuC;IAC1D,IAAI,YAAY,KAAK,SAAS,IAAI,YAAY,KAAK,IAAI,EAAE;QACvD,OAAO,KAAK,CAAC;KACd;IAED,MAAM,kBAAkB,GAAG,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;IAEpD,OAAO,kBAAkB,CAAC,cAAc,KAAK,SAAS,CAAC;AACzD,CAAC,qGAE2B,QAAuB,EAAE,UAAkB;IACrE,iCAAiC;IACjC,MAAM,cAAc,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE,CAAC,CAAC;QAC9D,aAAa,EAAE,iBAAiB,KAAK,IAAI,QAAQ,IAAI,UAAU,EAAE;QACjE,SAAS,EAAE,KAAK;KACjB,CAAC,CAAC,CAAC;IACJ,OAAO,cAAc,CAAC;AACxB,CAAC","sourcesContent":["import { bytesToHex } from '@metamask/utils';\n\nimport { SeedlessOnboardingControllerError } from './constants';\nimport { EncryptorDecryptor } from './encryption';\nimport { MetadataStore } from './MetadataStore';\nimport type { NodeAuthTokens, OAuthVerifier } from './types';\n\n/**\n * SEC1 encoded public key\n */\nexport type SEC1EncodedPublicKey = Uint8Array;\n\n/**\n * KeyPair - The encryption/decryption private and public key pair.\n *\n * privKey - The decryption private key in bigint format.\n *\n * pubKey - The encryption public key in SEC1 encoded format.\n */\nexport type KeyPair = {\n  sk: bigint;\n  pk: SEC1EncodedPublicKey;\n};\n\nexport type AuthenticationParams = {\n  // for now we only support one idToken, in future we will support multiple to remove commitment call\n  // so leaving it as an array for future use\n  idTokens: string[];\n  endpoints: string[];\n  indexes: number[];\n  verifier: OAuthVerifier;\n  verifierID: string;\n};\n\nexport type AuthenticationResult = {\n  /**\n   * The tokens issued by the nodes on verifying the idTokens\n   */\n  nodeAuthTokens: NodeAuthTokens;\n  /**\n   * The public key of the share if the user is an existing user\n   */\n  existingEncKeyPublicData?: {\n    pubKeyX: string;\n    pubKeyY: string;\n    keyIndex: number;\n  };\n  /**\n   * Whether the user is an existing user\n   */\n  hasValidEncKey: boolean;\n};\n\nexport type CreateEncKeyParams = {\n  /**\n   * The tokens issued by the nodes on verifying the idToken.\n   */\n  nodeAuthTokens: NodeAuthTokens;\n  /**\n   * The login provider of the user.\n   */\n  verifier: string;\n  /**\n   * The deterministic identifier of the user from the login provider.\n   */\n  verifierID: string;\n  /**\n   * The password of the user.\n   */\n  password: string;\n};\n\nexport type CreateEncKeyResult = {\n  /**\n   * The encryption key which is used to decrypt the secret data. This key is\n   * generated by client and threshold shared with the nodes using TOPRF\n   * protocol.\n   */\n  encKey: Uint8Array;\n\n  /**\n   * The authentication key which is used to provide valid signature for storing the secret data.\n   */\n  authKeyPair: KeyPair;\n};\n\n/**\n * nodeAuthTokens - The tokens issued by the nodes on authenticating the user.\n *\n * newPassword - The new password of the user.\n *\n * keyPair - The current encryption key of the user.\n *\n */\nexport type ChangeEncryptionKeyParams = {\n  /**\n   * The tokens issued by the nodes on verifying the idToken.\n   */\n  nodeAuthTokens: NodeAuthTokens;\n  /**\n   * The login provider of the user.\n   */\n  verifier: string;\n  /**\n   * The deterministic identifier of the user from the login provider.\n   */\n  verifierID: string;\n  /**\n   * The new password of the user.\n   */\n  password: string;\n  /**\n   * The current encryption key of the user.\n   */\n  oldEncKey: Uint8Array;\n  /**\n   * The current authentication key of the user.\n   */\n  oldAuthKeyPair: KeyPair;\n};\n\nexport type ChangeEncryptionKeyResult = {\n  /**\n   * The new encryption key of the user.\n   */\n  encKey: Uint8Array;\n  /**\n   * The new authentication key of the user.\n   */\n  authKeyPair: KeyPair;\n};\n\nexport type StoreSecretDataParams = {\n  /**\n   * The tokens issued by the nodes on verifying the idTokens\n   */\n  nodeAuthTokens: NodeAuthTokens;\n  /**\n   * The encryption key under which the secret data will be encrypted.\n   */\n  encKey: string;\n  /**\n   * The secret data in hex encoding.\n   */\n  secretData: string;\n};\n\nexport type BaseAddSecretDataItemParams<SecretDataType> = {\n  /**\n   * The tokens issued by the nodes on verifying the idToken.\n   */\n  nodeAuthTokens: NodeAuthTokens;\n  /**\n   * The secret data to be stored.\n   */\n  secretData: SecretDataType;\n\n  /**\n   * The encryption key to be used to encrypt the secret data.\n   */\n  encKey: Uint8Array;\n\n  /**\n   * The authentication key to be used to provide valid signature for storing the secret data.\n   */\n  authKeyPair: KeyPair;\n};\n\n/**\n * nodeAuthTokens - The tokens issued by the nodes on authenticating the user.\n *\n * keyPair - The encryption/decryption key pair which is used to encrypt the secret data before storing it.\n *\n * secretData - The secret data to be registered.\n */\nexport type AddSecretDataItemParams = BaseAddSecretDataItemParams<Uint8Array>;\n\nexport type BatchAddSecretDataItemParams = BaseAddSecretDataItemParams<\n  Uint8Array[]\n>;\n\nexport type StoreSecretDataResult = {\n  /**\n   * The encryption key which is used to decrypt the secret data.\n   * This key is generated by client and threshold shared with the nodes using TOPRF protocol.\n   */\n  encKey: string;\n  /**\n   * The encrypted secret data\n   */\n  encryptedSecretData: string;\n};\n\n/**\n * keyPair - The encryption/decryption key pair which is used to decrypt the secret data.\n */\nexport type FetchAllSecretDataParams = {\n  /**\n   * The tokens issued by the nodes on verifying the idToken.\n   */\n  nodeAuthTokens: NodeAuthTokens;\n  /**\n   * The decryption key to be used to decrypt the secret data.\n   */\n  decKey: Uint8Array;\n\n  /**\n   * The authentication key to be used to provide valid signature for fetching the secret data.\n   */\n  authKeyPair: KeyPair;\n};\n\nexport type FetchSecretDataResult = {\n  /**\n   * The encryption key which is used to decrypt the secret data.\n   * This key is generated by client and threshold shared with the nodes using TOPRF protocol.\n   */\n  encKey: string;\n  /**\n   * The secret data to be fetched\n   */\n  secretData: string[] | null;\n};\n\n// TODO: remove the class once the toprf-sdk is ready\n// This class is a mock implementation for the toprf-sdk\nexport class ToprfAuthClient {\n  readonly #mockAuthStore: MetadataStore = new MetadataStore('auth');\n\n  readonly #mockMetadataStore: MetadataStore = new MetadataStore('metadata');\n\n  // TODO: remove this once the toprf-sdk is ready\n  // encryptions/signings should be done in the toprf-sdk\n  readonly #encryptor: EncryptorDecryptor;\n\n  constructor() {\n    this.#encryptor = new EncryptorDecryptor();\n  }\n\n  /**\n   * Mock implementation of the authenticate method\n   *\n   * @param params - The parameters for the authentication\n   * @returns The authentication result\n   */\n  async authenticate(\n    params: AuthenticationParams,\n  ): Promise<AuthenticationResult> {\n    const key = `${params.verifier}:${params.verifierID}`;\n    const authenticationResult = await this.#mockAuthStore.get<string>(key);\n    let hasValidEncKey = false;\n    let nodeAuthTokens: NodeAuthTokens;\n\n    const isValidAuthResponse = this.#isValidAuthResponse(authenticationResult);\n    if (authenticationResult === undefined || !isValidAuthResponse) {\n      // generate mock nodeAuthTokens\n      nodeAuthTokens = this.#generateMockNodeAuthTokens(\n        params.verifier,\n        params.verifierID,\n      );\n      const data = JSON.stringify({\n        nodeAuthTokens,\n        hasValidEncKey,\n      });\n      await this.#mockAuthStore.set(key, data);\n    } else {\n      const parsedAuthenticationResult = JSON.parse(authenticationResult);\n      nodeAuthTokens = parsedAuthenticationResult.nodeAuthTokens;\n      hasValidEncKey = Boolean(parsedAuthenticationResult.hasValidEncKey);\n    }\n\n    return {\n      nodeAuthTokens,\n      hasValidEncKey,\n    };\n  }\n\n  /**\n   * Mock implementation of the createEncKey method\n   * This method derives the encryption key from the password with Threshold OPRF\n   *\n   * @param params - The parameters for the createEncKey\n   * @returns The createEncKey result\n   */\n  async createEncKey(params: CreateEncKeyParams): Promise<CreateEncKeyResult> {\n    const key = `${params.verifier}:${params.verifierID}`;\n    const data = JSON.stringify({\n      nodeAuthTokens: params.nodeAuthTokens,\n      hasValidEncKey: true,\n    });\n    await this.#mockAuthStore.set(key, data);\n\n    const encKey = this.#encryptor.keyFromPassword(params.password);\n\n    const authKeyPair = this.#encryptor.authKeyPairFromPassword(\n      params.password,\n    );\n    return {\n      encKey,\n      authKeyPair,\n    };\n  }\n\n  /**\n   * This function replaces the existing encryption key with a new one and copies the secret data of existing encryption key to the new one.\n   *\n   * @param params - The parameters for changing the encryption key.\n   * @param params.nodeAuthTokens - The tokens issued by the nodes on authenticating the user.\n   * @param params.newPassword - The new password of the user.\n   * @param params.keyPair - The current encryption key of the user.\n   *\n   * @returns A promise that resolves with the new encryption key.\n   */\n  async changeEncKey(\n    params: ChangeEncryptionKeyParams,\n  ): Promise<ChangeEncryptionKeyResult> {\n    try {\n      const key = `${params.verifier}:${params.verifierID}`;\n      const data = JSON.stringify({\n        nodeAuthTokens: params.nodeAuthTokens,\n        hasValidEncKey: true,\n      });\n      await this.#mockAuthStore.set(key, data);\n\n      const encKey = this.#encryptor.keyFromPassword(params.password);\n      const authKeyPair = this.#encryptor.authKeyPairFromPassword(\n        params.password,\n      );\n      return {\n        encKey,\n        authKeyPair,\n      };\n    } catch (e) {\n      throw new Error(SeedlessOnboardingControllerError.IncorrectPassword);\n    }\n  }\n\n  /**\n   * This function encrypts the secret data using the encryption key and stores it nodes metadata store in encrypted form.\n   *\n   * @param params - The parameters for registering new secret data.\n   * @param params.nodeAuthTokens - The tokens issued by the nodes on authenticating the user.\n   * @param params.keyPair - The encryption/decryption key pair which is used to encrypt the secret data before storing it.\n   * @param params.secretData - The array of secret data to be registered.\n   *\n   * @returns A promise that resolves if the operation is successful.\n   */\n  async addSecretDataItem(params: AddSecretDataItemParams): Promise<void> {\n    const { encKey, secretData } = params;\n\n    const encryptedSecretData = this.#encryptor.encrypt(encKey, secretData);\n\n    const pubKey = bytesToHex(params.authKeyPair.pk);\n    await this.#mockMetadataStore.set(pubKey, encryptedSecretData);\n  }\n\n  /**\n   * This function fetches all secret data items associated with the given\n   * auth pub key, decrypts, and returns them.\n   *\n   * @param params - The parameters for fetching the secret data.\n   * @param params.nodeAuthTokens - The tokens issued by the nodes on authenticating the user.\n   * @param params.decKey - The decryption key to be used to decrypt the secret data.\n   * @param params.authKeyPair - The authentication key to be used to provide valid signature for fetching the secret data.\n   *\n   * @returns A promise that resolves with the decrypted secret data. Null if no secret data is found.\n   */\n  async fetchAllSecretData(\n    params: FetchAllSecretDataParams,\n  ): Promise<Uint8Array[]> {\n    const pubKey = bytesToHex(params.authKeyPair.pk);\n    const encryptedSecretData =\n      (await this.#mockMetadataStore.get<string[]>(pubKey)) || [];\n\n    const secretData: Uint8Array[] = [];\n    try {\n      const decryptedSecretData = encryptedSecretData.map((data) => {\n        const rawData = new Uint8Array(Buffer.from(data, 'base64'));\n        return this.#encryptor.decrypt(params.decKey, rawData);\n      });\n      secretData.push(...decryptedSecretData);\n    } catch (e) {\n      throw new Error(SeedlessOnboardingControllerError.IncorrectPassword);\n    }\n\n    return secretData;\n  }\n\n  #isValidAuthResponse(authResponse: string | null | undefined): boolean {\n    if (authResponse === undefined || authResponse === null) {\n      return false;\n    }\n\n    const parsedAuthResponse = JSON.parse(authResponse);\n\n    return parsedAuthResponse.nodeAuthTokens !== undefined;\n  }\n\n  #generateMockNodeAuthTokens(verifier: OAuthVerifier, verifierID: string) {\n    // generate 5 mock nodeAuthTokens\n    const nodeAuthTokens = Array.from({ length: 5 }, (_, index) => ({\n      nodeAuthToken: `nodeAuthToken-${index}-${verifier}-${verifierID}`,\n      nodeIndex: index,\n    }));\n    return nodeAuthTokens;\n  }\n}\n"]}