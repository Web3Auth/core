import { SeedlessOnboardingControllerError } from './constants';
import { EncryptorDecryptor } from './encryption';
import { MetadataStore } from './MetadataStore';
import type { NodeAuthTokens } from './types';

export type AuthenticationParams = {
  // for now we only support one idToken, in future we will support multiple to remove commitment call
  // so leaving it as an array for future use
  idTokens: string[];
  endpoints: string[];
  indexes: number[];
  verifier: string;
  verifierID: string;
};

export type AuthenticationResult = {
  /**
   * The tokens issued by the nodes on verifying the idTokens
   */
  nodeAuthTokens: NodeAuthTokens;
  /**
   * The public key of the share if the user is an existing user
   */
  existingEncKeyPublicData?: {
    pubKeyX: string;
    pubKeyY: string;
    keyIndex: number;
  };
  /**
   * Whether the user is an existing user
   */
  hasValidEncKey: boolean;
};

export type CreateEncKeyParams = {
  /**
   * The tokens issued by the nodes on verifying the idToken.
   */
  nodeAuthTokens: NodeAuthTokens;
  /**
   * The login provider of the user.
   */
  verifier: string;
  /**
   * The deterministic identifier of the user from the login provider.
   */
  verifierID: string;
  /**
   * The password of the user.
   */
  password: string;
};

export type CreateEncKeyResult = {
  /**
   * The encryption key which is used to decrypt the secret data. This key is
   * generated by client and threshold shared with the nodes using TOPRF
   * protocol.
   */
  encKey: string;
};

export type StoreSecretDataParams = {
  /**
   * The tokens issued by the nodes on verifying the idTokens
   */
  nodeAuthTokens: NodeAuthTokens;
  /**
   * The encryption key under which the secret data will be encrypted.
   */
  encKey: string;
  /**
   * The secret data in hex encoding.
   */
  secretData: string;
};

export type StoreSecretDataResult = {
  /**
   * The encryption key which is used to decrypt the secret data.
   * This key is generated by client and threshold shared with the nodes using TOPRF protocol.
   */
  encKey: string;
  /**
   * The encrypted secret data
   */
  encryptedSecretData: string;
};

export type FetchSecretDataParams = {
  /**
   * The tokens issued by the nodes on verifying the idToken.
   */
  nodeAuthTokens: NodeAuthTokens;
  /**
   * The key to decrypt the secret data.
   */
  encKey: string;
};

export type FetchSecretDataResult = {
  /**
   * The encryption key which is used to decrypt the secret data.
   * This key is generated by client and threshold shared with the nodes using TOPRF protocol.
   */
  encKey: string;
  /**
   * The secret data to be fetched
   */
  secretData: string[] | null;
};

// TODO: remove the class once the toprf-sdk is ready
// This class is a mock implementation for the toprf-sdk
export class ToprfAuthClient {
  readonly #mockAuthStore: MetadataStore = new MetadataStore('auth');

  readonly #mockMetadataStore: MetadataStore = new MetadataStore('metadata');

  // TODO: remove this once the toprf-sdk is ready
  // encryptions/signings should be done in the toprf-sdk
  readonly #encryptor: EncryptorDecryptor;

  constructor() {
    this.#encryptor = new EncryptorDecryptor();
  }

  /**
   * Mock implementation of the authenticate method
   *
   * @param params - The parameters for the authentication
   * @returns The authentication result
   */
  async authenticate(
    params: AuthenticationParams,
  ): Promise<AuthenticationResult> {
    const key = `${params.verifier}:${params.verifierID}`;
    const authenticationResult = await this.#mockAuthStore.get(key);
    let hasValidEncKey = false;
    let nodeAuthTokens: NodeAuthTokens;

    const isValidAuthResponse = this.#isValidAuthResponse(authenticationResult);
    if (authenticationResult === undefined || !isValidAuthResponse) {
      // generate mock nodeAuthTokens
      nodeAuthTokens = Array.from(
        { length: params.indexes.length },
        (_, index) => ({
          nodeAuthToken: `nodeAuthToken-${index}-${params.verifier}-${params.verifierID}`,
          nodeIndex: params.indexes[index],
        }),
      );
      const data = JSON.stringify({
        nodeAuthTokens,
        hasValidEncKey,
      });
      await this.#mockAuthStore.set(key, data);
    } else {
      const parsedAuthenticationResult = JSON.parse(authenticationResult);
      nodeAuthTokens = parsedAuthenticationResult.nodeAuthTokens;
      hasValidEncKey = Boolean(parsedAuthenticationResult.hasValidEncKey);
    }

    return {
      nodeAuthTokens,
      hasValidEncKey,
    };
  }

  /**
   * Mock implementation of the createEncKey method
   * This method derives the encryption key from the password with Threshold OPRF
   *
   * @param params - The parameters for the createEncKey
   * @returns The createEncKey result
   */
  async createEncKey(params: CreateEncKeyParams): Promise<CreateEncKeyResult> {
    try {
      const key = `${params.verifier}:${params.verifierID}`;
      const data = JSON.stringify({
        nodeAuthTokens: params.nodeAuthTokens,
        hasValidEncKey: true,
      });
      await this.#mockAuthStore.set(key, data);

      const encKey = this.#encryptor.keyFromPassword(params.password);
      return {
        encKey,
      };
    } catch (e) {
      throw new Error(SeedlessOnboardingControllerError.IncorrectPassword);
    }
  }

  async storeSecretData(
    params: StoreSecretDataParams,
  ): Promise<StoreSecretDataResult> {
    const { nodeAuthTokens, encKey, secretData } = params;

    const encryptedSecretData = this.#encryptor.encrypt(encKey, secretData);

    const key = nodeAuthTokens.reduce(
      (acc, token) => `${acc}:${token.nodeAuthToken}`,
      '',
    );
    await this.#mockMetadataStore.set(key, encryptedSecretData);

    return {
      encKey,
      encryptedSecretData,
    };
  }

  async fetchSecretData(
    params: FetchSecretDataParams,
  ): Promise<FetchSecretDataResult> {
    const key = params.nodeAuthTokens.reduce(
      (acc, token) => `${acc}:${token.nodeAuthToken}`,
      '',
    );
    const encryptedSecretData = await this.#mockMetadataStore.get(key);

    let secretData: string | null = null;
    try {
      secretData = encryptedSecretData
        ? this.#encryptor.decrypt(params.encKey, encryptedSecretData)
        : null;
    } catch (e) {
      throw new Error(SeedlessOnboardingControllerError.IncorrectPassword);
    }

    return {
      encKey: params.encKey,
      secretData: secretData ? [secretData] : null,
    };
  }

  #isValidAuthResponse(authResponse: string | null | undefined): boolean {
    if (authResponse === undefined || authResponse === null) {
      return false;
    }

    const parsedAuthResponse = JSON.parse(authResponse);

    return parsedAuthResponse.nodeAuthTokens !== undefined;
  }
}
