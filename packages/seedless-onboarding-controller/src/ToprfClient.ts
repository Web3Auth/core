import { bytesToHex } from '@metamask/utils';

import { SeedlessOnboardingControllerError } from './constants';
import { EncryptorDecryptor } from './encryption';
import { MetadataStore } from './MetadataStore';
import type { NodeAuthTokens, OAuthVerifier } from './types';

/**
 * SEC1 encoded public key
 */
export type SEC1EncodedPublicKey = Uint8Array;

/**
 * KeyPair - The encryption/decryption private and public key pair.
 *
 * privKey - The decryption private key in bigint format.
 *
 * pubKey - The encryption public key in SEC1 encoded format.
 */
export type KeyPair = {
  sk: bigint;
  pk: SEC1EncodedPublicKey;
};

export type AuthenticationParams = {
  // for now we only support one idToken, in future we will support multiple to remove commitment call
  // so leaving it as an array for future use
  idTokens: string[];
  endpoints: string[];
  indexes: number[];
  verifier: OAuthVerifier;
  verifierID: string;
};

export type AuthenticationResult = {
  /**
   * The tokens issued by the nodes on verifying the idTokens
   */
  nodeAuthTokens: NodeAuthTokens;
  /**
   * The public key of the share if the user is an existing user
   */
  existingEncKeyPublicData?: {
    pubKeyX: string;
    pubKeyY: string;
    keyIndex: number;
  };
  /**
   * Whether the user is an existing user
   */
  hasValidEncKey: boolean;
};

export type CreateEncKeyParams = {
  /**
   * The tokens issued by the nodes on verifying the idToken.
   */
  nodeAuthTokens: NodeAuthTokens;
  /**
   * The login provider of the user.
   */
  verifier: string;
  /**
   * The deterministic identifier of the user from the login provider.
   */
  verifierID: string;
  /**
   * The password of the user.
   */
  password: string;
};

export type CreateEncKeyResult = {
  /**
   * The encryption key which is used to decrypt the secret data. This key is
   * generated by client and threshold shared with the nodes using TOPRF
   * protocol.
   */
  encKey: Uint8Array;

  /**
   * The authentication key which is used to provide valid signature for storing the secret data.
   */
  authKeyPair: KeyPair;
};

/**
 * nodeAuthTokens - The tokens issued by the nodes on authenticating the user.
 *
 * newPassword - The new password of the user.
 *
 * keyPair - The current encryption key of the user.
 *
 */
export type ChangeEncryptionKeyParams = {
  /**
   * The tokens issued by the nodes on verifying the idToken.
   */
  nodeAuthTokens: NodeAuthTokens;
  /**
   * The login provider of the user.
   */
  verifier: string;
  /**
   * The deterministic identifier of the user from the login provider.
   */
  verifierID: string;
  /**
   * The new password of the user.
   */
  password: string;
  /**
   * The current encryption key of the user.
   */
  oldEncKey: Uint8Array;
  /**
   * The current authentication key of the user.
   */
  oldAuthKeyPair: KeyPair;
};

export type ChangeEncryptionKeyResult = {
  /**
   * The new encryption key of the user.
   */
  encKey: Uint8Array;
  /**
   * The new authentication key of the user.
   */
  authKeyPair: KeyPair;
};

export type StoreSecretDataParams = {
  /**
   * The tokens issued by the nodes on verifying the idTokens
   */
  nodeAuthTokens: NodeAuthTokens;
  /**
   * The encryption key under which the secret data will be encrypted.
   */
  encKey: string;
  /**
   * The secret data in hex encoding.
   */
  secretData: string;
};

export type BaseAddSecretDataItemParams<SecretDataType> = {
  /**
   * The tokens issued by the nodes on verifying the idToken.
   */
  nodeAuthTokens: NodeAuthTokens;
  /**
   * The secret data to be stored.
   */
  secretData: SecretDataType;

  /**
   * The encryption key to be used to encrypt the secret data.
   */
  encKey: Uint8Array;

  /**
   * The authentication key to be used to provide valid signature for storing the secret data.
   */
  authKeyPair: KeyPair;
};

/**
 * nodeAuthTokens - The tokens issued by the nodes on authenticating the user.
 *
 * keyPair - The encryption/decryption key pair which is used to encrypt the secret data before storing it.
 *
 * secretData - The secret data to be registered.
 */
export type AddSecretDataItemParams = BaseAddSecretDataItemParams<Uint8Array>;

export type BatchAddSecretDataItemParams = BaseAddSecretDataItemParams<
  Uint8Array[]
>;

export type StoreSecretDataResult = {
  /**
   * The encryption key which is used to decrypt the secret data.
   * This key is generated by client and threshold shared with the nodes using TOPRF protocol.
   */
  encKey: string;
  /**
   * The encrypted secret data
   */
  encryptedSecretData: string;
};

/**
 * keyPair - The encryption/decryption key pair which is used to decrypt the secret data.
 */
export type FetchAllSecretDataParams = {
  /**
   * The tokens issued by the nodes on verifying the idToken.
   */
  nodeAuthTokens: NodeAuthTokens;
  /**
   * The decryption key to be used to decrypt the secret data.
   */
  decKey: Uint8Array;

  /**
   * The authentication key to be used to provide valid signature for fetching the secret data.
   */
  authKeyPair: KeyPair;
};

export type FetchSecretDataResult = {
  /**
   * The encryption key which is used to decrypt the secret data.
   * This key is generated by client and threshold shared with the nodes using TOPRF protocol.
   */
  encKey: string;
  /**
   * The secret data to be fetched
   */
  secretData: string[] | null;
};

// TODO: remove the class once the toprf-sdk is ready
// This class is a mock implementation for the toprf-sdk
export class ToprfAuthClient {
  readonly #mockAuthStore: MetadataStore = new MetadataStore('auth');

  readonly #mockMetadataStore: MetadataStore = new MetadataStore('metadata');

  // TODO: remove this once the toprf-sdk is ready
  // encryptions/signings should be done in the toprf-sdk
  readonly #encryptor: EncryptorDecryptor;

  constructor() {
    this.#encryptor = new EncryptorDecryptor();
  }

  /**
   * Mock implementation of the authenticate method
   *
   * @param params - The parameters for the authentication
   * @returns The authentication result
   */
  async authenticate(
    params: AuthenticationParams,
  ): Promise<AuthenticationResult> {
    const key = `${params.verifier}:${params.verifierID}`;
    const authenticationResult = await this.#mockAuthStore.get<string>(key);
    let hasValidEncKey = false;
    let nodeAuthTokens: NodeAuthTokens;

    const isValidAuthResponse = this.#isValidAuthResponse(authenticationResult);
    if (authenticationResult === undefined || !isValidAuthResponse) {
      // generate mock nodeAuthTokens
      nodeAuthTokens = this.#generateMockNodeAuthTokens(
        params.verifier,
        params.verifierID,
      );
      const data = JSON.stringify({
        nodeAuthTokens,
        hasValidEncKey,
      });
      await this.#mockAuthStore.set(key, data);
    } else {
      const parsedAuthenticationResult = JSON.parse(authenticationResult);
      nodeAuthTokens = parsedAuthenticationResult.nodeAuthTokens;
      hasValidEncKey = Boolean(parsedAuthenticationResult.hasValidEncKey);
    }

    return {
      nodeAuthTokens,
      hasValidEncKey,
    };
  }

  /**
   * Mock implementation of the createEncKey method
   * This method derives the encryption key from the password with Threshold OPRF
   *
   * @param params - The parameters for the createEncKey
   * @returns The createEncKey result
   */
  async createEncKey(params: CreateEncKeyParams): Promise<CreateEncKeyResult> {
    const key = `${params.verifier}:${params.verifierID}`;
    const data = JSON.stringify({
      nodeAuthTokens: params.nodeAuthTokens,
      hasValidEncKey: true,
    });
    await this.#mockAuthStore.set(key, data);

    const encKey = this.#encryptor.keyFromPassword(params.password);

    const authKeyPair = this.#encryptor.authKeyPairFromPassword(
      params.password,
    );
    return {
      encKey,
      authKeyPair,
    };
  }

  /**
   * This function replaces the existing encryption key with a new one and copies the secret data of existing encryption key to the new one.
   *
   * @param params - The parameters for changing the encryption key.
   * @param params.nodeAuthTokens - The tokens issued by the nodes on authenticating the user.
   * @param params.newPassword - The new password of the user.
   * @param params.keyPair - The current encryption key of the user.
   *
   * @returns A promise that resolves with the new encryption key.
   */
  async changeEncKey(
    params: ChangeEncryptionKeyParams,
  ): Promise<ChangeEncryptionKeyResult> {
    try {
      const key = `${params.verifier}:${params.verifierID}`;
      const data = JSON.stringify({
        nodeAuthTokens: params.nodeAuthTokens,
        hasValidEncKey: true,
      });
      await this.#mockAuthStore.set(key, data);

      const encKey = this.#encryptor.keyFromPassword(params.password);
      const authKeyPair = this.#encryptor.authKeyPairFromPassword(
        params.password,
      );
      return {
        encKey,
        authKeyPair,
      };
    } catch (e) {
      throw new Error(SeedlessOnboardingControllerError.IncorrectPassword);
    }
  }

  /**
   * This function encrypts the secret data using the encryption key and stores it nodes metadata store in encrypted form.
   *
   * @param params - The parameters for registering new secret data.
   * @param params.nodeAuthTokens - The tokens issued by the nodes on authenticating the user.
   * @param params.keyPair - The encryption/decryption key pair which is used to encrypt the secret data before storing it.
   * @param params.secretData - The array of secret data to be registered.
   *
   * @returns A promise that resolves if the operation is successful.
   */
  async addSecretDataItem(params: AddSecretDataItemParams): Promise<void> {
    const { encKey, secretData } = params;

    const encryptedSecretData = this.#encryptor.encrypt(encKey, secretData);

    const pubKey = bytesToHex(params.authKeyPair.pk);
    await this.#mockMetadataStore.set(pubKey, encryptedSecretData);
  }

  /**
   * This function fetches all secret data items associated with the given
   * auth pub key, decrypts, and returns them.
   *
   * @param params - The parameters for fetching the secret data.
   * @param params.nodeAuthTokens - The tokens issued by the nodes on authenticating the user.
   * @param params.decKey - The decryption key to be used to decrypt the secret data.
   * @param params.authKeyPair - The authentication key to be used to provide valid signature for fetching the secret data.
   *
   * @returns A promise that resolves with the decrypted secret data. Null if no secret data is found.
   */
  async fetchAllSecretData(
    params: FetchAllSecretDataParams,
  ): Promise<Uint8Array[]> {
    const pubKey = bytesToHex(params.authKeyPair.pk);
    const encryptedSecretData =
      (await this.#mockMetadataStore.get<string[]>(pubKey)) || [];

    const secretData: Uint8Array[] = [];
    try {
      const decryptedSecretData = encryptedSecretData.map((data) => {
        const rawData = new Uint8Array(Buffer.from(data, 'base64'));
        return this.#encryptor.decrypt(params.decKey, rawData);
      });
      secretData.push(...decryptedSecretData);
    } catch (e) {
      throw new Error(SeedlessOnboardingControllerError.IncorrectPassword);
    }

    return secretData;
  }

  #isValidAuthResponse(authResponse: string | null | undefined): boolean {
    if (authResponse === undefined || authResponse === null) {
      return false;
    }

    const parsedAuthResponse = JSON.parse(authResponse);

    return parsedAuthResponse.nodeAuthTokens !== undefined;
  }

  #generateMockNodeAuthTokens(verifier: OAuthVerifier, verifierID: string) {
    // generate 5 mock nodeAuthTokens
    const nodeAuthTokens = Array.from({ length: 5 }, (_, index) => ({
      nodeAuthToken: `nodeAuthToken-${index}-${verifier}-${verifierID}`,
      nodeIndex: index,
    }));
    return nodeAuthTokens;
  }
}
