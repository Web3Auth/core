import type { EncryptionResult } from '@metamask/browser-passworder';

import type { Encryptor, NodeAuthTokens } from './types';

export type AuthenticationParams = {
  // for now we only support one idToken, in future we will support multiple to remove commitment call
  // so leaving it as an array for future use
  idTokens: string[];
  endpoints: string[];
  indexes: number[];
  verifier: string;
  verifierID: string;
};

export type AuthenticationResult = {
  /**
   * The tokens issued by the nodes on verifying the idTokens
   */
  nodeAuthTokens: NodeAuthTokens;
  /**
   * The public key of the share if the user is an existing user
   */
  existingEncKeyPublicData?: {
    pubKeyX: string;
    pubKeyY: string;
    keyIndex: number;
  };
  /**
   * Whether the user is an existing user
   */
  isExistingUser: boolean;
};

export type CreateEncKeyParams = {
  /**
   * The tokens issued by the nodes on verifying the idToken.
   */
  nodeAuthTokens: NodeAuthTokens;
  /**
   * The password of the user.
   */
  password: string;
};

export type CreateEncKeyResult = {
  /**
   * The encryption key which is used to decrypt the secret data. This key is
   * generated by client and threshold shared with the nodes using TOPRF
   * protocol.
   */
  encKey: string;
};

export type StoreSecretDataParams = {
  /**
   * The tokens issued by the nodes on verifying the idTokens
   */
  nodeAuthTokens: NodeAuthTokens;
  /**
   * The encryption key under which the secret data will be encrypted.
   */
  encKey: string;
  /**
   * The secret data in hex encoding.
   */
  secretData: string;
};

export type StoreSecretDataResult = {
  /**
   * The encryption key which is used to decrypt the secret data.
   * This key is generated by client and threshold shared with the nodes using TOPRF protocol.
   */
  encKey: string;
  /**
   * The encrypted secret data
   */
  encryptedSecretData: string;
};

export type FetchSecretDataParams = {
  /**
   * The tokens issued by the nodes on verifying the idToken.
   */
  nodeAuthTokens: NodeAuthTokens;
  /**
   * The password of the user.
   */
  password: string;
};

export type FetchSecretDataResult = {
  /**
   * The encryption key which is used to decrypt the secret data.
   * This key is generated by client and threshold shared with the nodes using TOPRF protocol.
   */
  encKey: string;
  /**
   * The secret data to be fetched
   */
  secretData: string[] | null;
};

// TODO: remove the class once the toprf-sdk is ready
// This class is a mock implementation for the toprf-sdk
export class ToprfAuthClient {
  readonly #mockAuthStore: Map<string, string> = new Map();

  readonly #mockMetadataStore: Map<string, string> = new Map();

  // TODO: remove this once the toprf-sdk is ready
  // encryptions/signings should be done in the toprf-sdk
  readonly #encryptor: Encryptor;

  constructor(encryptor: Encryptor) {
    this.#encryptor = encryptor;
  }

  /**
   * Mock implementation of the authenticate method
   *
   * @param params - The parameters for the authentication
   * @returns The authentication result
   */
  async authenticate(
    params: AuthenticationParams,
  ): Promise<AuthenticationResult> {
    const key = `${params.verifier}:${params.verifierID}`;

    const stringifiedNodeAuthTokens = this.#mockAuthStore.get(key);
    let nodeAuthTokens: NodeAuthTokens;

    if (stringifiedNodeAuthTokens === undefined) {
      // generate mock nodeAuthTokens
      nodeAuthTokens = Array.from(
        { length: params.indexes.length },
        (_, index) => ({
          nodeAuthToken: `nodeAuthToken-${index}-${params.verifier}-${params.verifierID}`,
          nodeIndex: params.indexes[index],
        }),
      );
      this.#mockAuthStore.set(key, JSON.stringify(nodeAuthTokens));
    } else {
      nodeAuthTokens = JSON.parse(stringifiedNodeAuthTokens);
    }
    // TODO: do the threshold check

    return {
      nodeAuthTokens,
      isExistingUser: Boolean(stringifiedNodeAuthTokens),
    };
  }

  /**
   * Mock implementation of the createEncKey method
   * This method derives the encryption key from the password with Threshold OPRF
   *
   * @param params - The parameters for the createEncKey
   * @returns The createEncKey result
   */
  async createEncKey(params: CreateEncKeyParams): Promise<CreateEncKeyResult> {
    // NOTE: this is a mock implementation
    // actual implementation involves threshold oprf
    const cryptoKey = await this.#encryptor.keyFromPassword(params.password);
    const key = 'key' in cryptoKey ? cryptoKey.key : cryptoKey;
    const encKey = await this.#encryptor.exportKey(key);

    return {
      encKey,
    };
  }

  async storeSecretData(
    params: StoreSecretDataParams,
  ): Promise<StoreSecretDataResult> {
    const { nodeAuthTokens, encKey, secretData } = params;

    const encryptedSecretData = await this.#encryptSecretData(
      encKey,
      secretData,
    );

    const key = nodeAuthTokens.reduce(
      (acc, token) => `${acc}:${token.nodeAuthToken}`,
      '',
    );
    this.#mockMetadataStore.set(key, encryptedSecretData);

    return {
      encKey,
      encryptedSecretData,
    };
  }

  async fetchSecretData(
    params: FetchSecretDataParams,
  ): Promise<FetchSecretDataResult> {
    const { encKey } = await this.createEncKey(params);

    const key = params.nodeAuthTokens.reduce(
      (acc, token) => `${acc}:${token.nodeAuthToken}`,
      '',
    );

    const encryptedSecretData = this.#mockMetadataStore.get(key);

    const secretData = encryptedSecretData
      ? await this.#decryptSecretData(encKey, encryptedSecretData)
      : null;

    return {
      encKey,
      secretData: secretData ? [secretData] : null,
    };
  }

  async #encryptSecretData(
    encKeyString: string,
    secretData: string,
  ): Promise<string> {
    const encryptionKey = await this.#encryptor.importKey(encKeyString);
    const encryptedSecretData = await this.#encryptor.encryptWithKey(
      encryptionKey,
      secretData,
    );

    return JSON.stringify(encryptedSecretData);
  }

  async #decryptSecretData(
    encKeyString: string,
    encryptedSecretData: string,
  ): Promise<string> {
    let encryptedResult: EncryptionResult;
    try {
      encryptedResult = JSON.parse(encryptedSecretData) as EncryptionResult;
    } catch (error: unknown) {
      console.error(error);
      throw new Error('Fail to encrypt. Invalid data');
    }
    const decryptionKey = await this.#encryptor.importKey(encKeyString);
    const decryptedResult = await this.#encryptor.decryptWithKey(
      decryptionKey,
      encryptedResult,
    );

    return decryptedResult as string;
  }
}
